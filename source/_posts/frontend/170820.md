---
title: JS中Math对象及位运算使用总结
date: 2017-08-20
categories:
  - 前端
tags:
  - frontend
  - algorithm
---

## Math 对象

### 属性

|    属性名    |             描述             |    值    |
| :----------: | :--------------------------: | :------: |
|    Math.E    | 欧拉常数，也是自然对数的底数 | 约 2.718 |
|   Math.LN2   |         2 的自然对数         | 约 0.693 |
|  Math.LN10   |        10 的自然对数         | 约 2.303 |
|  Math.LOG2E  |      以 2 为底 E 的对数      | 约 1.443 |
| Math.LOG10E  |     以 10 为底 E 的对数      | 约 0.434 |
|   Math.PI    |            圆周率            | 约 3.14  |
| Math.SQRT1_2 |         1/2 的平方根         | 约 0.707 |
|  Math.SQRT2  |          2 的平方根          | 约 1.414 |

### 方法

#### 三角函数

|      方法名      |         描述          |
| :--------------: | :-------------------: |
|   Math.sin(x)    |    返回 x 的正弦值    |
|   Math.sinh(x)   |  返回 x 的双曲正弦值  |
|   Math.cos(x)    |    返回 x 的余弦值    |
|   Math.cosh(x)   |  返回 x 的双曲余弦值  |
|   Math.tan(x)    |    返回 x 的正切值    |
|   Math.tanh(x)   |  返回 x 的双曲正切值  |
|   Math.asin(x)   |   返回 x 的反正弦值   |
|  Math.asinh(x)   | 返回 x 的反双曲正弦值 |
|   Math.acos(x)   |   返回 x 的反余弦值   |
|   Math.atan(x)   |   返回 x 的反正切值   |
| Math.atan2(x, y) |  返回 y/x 的反正切值  |
|  Math.atanh(x)   | 返回 x 的反双曲正切值 |

#### 数学运算

|      方法名       |                    描述                     |             例子              |
| :---------------: | :-----------------------------------------: | :---------------------------: |
|   Math.sqrt(x)    |               返回 x 的平方根               |       Math.sqrt(9);//3        |
|    Math.exp(x)    |          返回欧拉常数(e)的 x 次幂           |    Math.exp(1);//约 2.718     |
|   Math.pow(x,y)   | 返回 x 的 y 次幂, 如果 y 未初始化, 则返回 x |      Math.pow(2, 3);//8       |
|   Math.expm1(x)   |     返回欧拉常数(e)的 x 次幂减去 1 的值     |    Math.exp(1);//约 1.718     |
|    Math.log(x)    |              返回 x 的自然对数              |        Math.log(1);//0        |
|   Math.log1p(x)   |            返回 x+1 后的自然对数            |       Math.log1p(0);//0       |
|   Math.log2(x)    |           返回 x 以 2 为底的对数            |       Math.log2(8);//3        |
|   Math.log10(x)   |           返回 x 以 10 为底的对数           |      Math.log10(100);//2      |
|   Math.cbrt(x)    |               返回 x 的立方根               |      Math.cbrt(8);//约 2      |
|   Math.clz32()    | 返回数字转换为 32 位二进制后开头的 0 的个数 |      Math.clz32(2);//30       |
| Math.hypot(x,y,z) |        返回所有参数的平方和的平方根         |      Math.hypot(3,4);//5      |
|  Math.imul(x,y)   |   返回两个参数的 32 位整数乘法运算的结果    | Math.imul(0xffffffff, 5);//-5 |

#### 数字运算

|     方法名      |                      描述                       |                 例子                 |
| :-------------: | :---------------------------------------------: | :----------------------------------: |
|   Math.abs(x)   |                 返回 x 的绝对值                 |           Math.abs(-5);//5           |
|  Math.floor(x)  |              返回小于 x 的最大整数              |         Math.floor(8.2);//8          |
|  Math.ceil(x)   |              返回大于 x 的最小整数              |          Math.ceil(8.2);//9          |
|  Math.trunc(x)  |                返回 x 的整数部分                |         Math.trunc(1.23);//1         |
| Math.fround(x)  |             返回最近的单精度浮点数              | Math.fround(1.1);//1.100000023841858 |
| Math.min(x,y,z) |              返回多个数中的最小值               |         Math.min(3,1,5);//1          |
| Math.max(x,y,z) |              返回多个数中的最大值               |         Math.max(3,1,5);//5          |
|  Math.round(x)  |              返回四舍五入后的整数               |         Math.round(8.2);//8          |
|  Math.random()  |           返回 0 到 1 之间的伪随机数            |            Math.random();            |
|  Math.sign(x)   | 返回一个数的符号( 返回值包括 1, -1, 0, -0, NaN) |          Math.sign(-5);//-1          |

### 规律

以上数值运算中, 存在如下规律:

- 没有参数或者参数为零的情况下, `toFixed()` 方法返回该数值的四舍五入后的整数形式, 等同于 Math.round(x); 其他情况下, 返回该数的指定小数位数的四舍五入后的结果.

- Math.trunc(x) 方法

  - `x` 为正数时, 运算结果同 Math.floor(x);
  - `x` 为负数时, 运算结果同 Math.ceil(x). 实际上, 它完全可以由位运算替代, 且运算速度更快, 如 `2.5&-1` 或 `2.5|0` 或 `~~2.5` 或 `2.5^0` , 它们的运算结果都为 2; 如 -`2.5&-1` 或 `-2.5|0` 或 `~~-2.5` 或 `-2.5^0` , 它们的运算结果都为-2;

- Math.min(x,y,z) 与 Math.max(x,y,z) 方法由于可接无限个参数, 可用于求数组元素的最小最大值. 如:

  ```js
  Math.max.apply(null, [5, 3, 8, 9]) // 9
  ```

  但是 Math.min 不传参数返回 `Infinity`, Math.max 不传参数返回 `-Infinity` .

- 稍微利用 Math.random() 方法的特性, 就可以生成任意范围的数字. 如: 生成 10 到 80 之间的随机数,

  ```js
  Math.random() * 70 + 10 // 返回 10~80 之间的随机数, 包含 10 不包含 80
  ```

除去上述方法, Math 作为对象, 继承了来之 Object 对象的方法. 其中一些如下:

```js
Math.valueOf() //返回 Math 对象本身
;+Math //NaN, 试图转换成数字,由于不能转换为数字,返回 NaN

Math.toString() //"[object Math]"
```

## 位运算

### 二进制

由于位运算是基于二进制的, 因此我们需要先获取数值的二进制值. 实际上, `toString` 方法已经帮我们做好了一部分工作, 如下:

```js
//正整数可通过toString获取
;(12).toString(2) //1100
//负整数问题就来了
;(-12).toString(2) //-1100
```

负数的十进制转换为二进制时,符号位不变,其它位取反后+1. 即: `-x的二进制 = x的二进制取反+1`. 由按位取反可借助^运算符, 故负整数的二进制可以借助下面这个函数来获取:

```js
function getBinary(num) {
  var s = (-num).toString(2),
    array = [].map.call(s, function(v) {
      return v ^ 1
    })
  array.reduceRight(function(previousValue, value, index, array) {
    var v = previousValue ^ value
    array[index] = v
    return +!v
  }, 1)
  return array.join('')
}
getBinary(-12) //0100, 前面未补全的部分全部为1
```

然后, 多试几次就会发现:

```js
getBinary(-1) == (1).toString(2) //true
getBinary(-2) == (2).toString(2) //true
getBinary(-4) == (4).toString(2) //true
getBinary(-8) == (8).toString(2) //true
```

> 这表明 2 的整数次方的值与它的相对数, 他们后面真正有效的那几位都相同.

由二进制转十进制和十进制转二进制的函数大部分都可以共用, 因此下面提供一个统一的函数解决它们的互转问题:

```js
function translateBinary(item) {
  var s = null,
    array = null,
    type = typeof item,
    symbol = !/^-/.test(item + '')
  switch (type) {
    case 'number':
      s = Math.abs(item).toString(2)
      if (symbol) {
        return s
      }
      break
    case 'string':
      if (symbol) {
        return parseInt(item, 2)
      }
      s = item.substring(1)
      break
    default:
      return false
  }
  //按位取反
  array = [].map.call(s, function(v) {
    return v ^ 1
  })
  //+1
  array.reduceRight(function(previousValue, value, index, array) {
    var v = previousValue + value == 2
    array[index] = previousValue ^ value
    return +v
  }, 1)
  s = array.join('')
  return type == 'number' ? '-' + s : -parseInt(s, 2)
}
translateBinary(-12) //"-0100"
translateBinary('-0100') //-12
```

### 按位非

`~` 运算符, 返回数值二进制补码形式的反码. 什么意思呢, 就是说一个数值二进制补码形式中的每一位都将取反, 如果该位为 1, 取反为 0, 如果该位为 0, 取反为 1. 我们来举个例子理解下:

```js
~   0000 0000 0000 0000 0000 0000 0000 0011    //3的32位二进制补码形式
--------------------------------------------
    1111 1111 1111 1111 1111 1111 1111 1100    //按位取反后为负数(最高位(第一位)表示正负,1代表负,0代表正)
--------------------------------------------
    1000 0000 0000 0000 0000 0000 0000 0011    //负数的二进制转换为十进制时,符号位不变,其它位取反(后+1)
    1000 0000 0000 0000 0000 0000 0000 0100 // +1
--------------------------------------------
                                      -4     //最终运算结果为-4
```

实际上, 按位非(~)操作不需要这么兴师动众地去计算, 它有且仅有一条运算规律:

> 按位非操作一个数值, 等同于这个数值加 1 然后符号改变. 即: `~x === -x-1`.

```js
~5 ==> -5-1 === -6;
~-2016 ==> 2016-1 === 2015;
```

由上述公式可推出: `~~x === -(-x-1)-1 === x`. 由于位运算摈除小数部分的特性, 连续两次按位非也可用于将非整数取整. 即 `~~x === Math.trunc(x)`.

按位非(~)运算符只能用来求数值的反码, 并且还不能输出反码的二进制字符串. 我们来稍微扩展下, 使它变得更易用.

```js
function waveExtend(item) {
  var s = typeof item == 'number' && translateBinary(~item)
  return typeof s == 'string'
    ? s
    : [].map
        .call(item, function(v) {
          return v === '-' ? v : v ^ 1
        })
        .join('')
        .replace(/^-?/, function(m) {
          return m == '' ? '-' : ''
        })
}
waveExtend(-8) //111 -8反码,正数省略的位全部为0
waveExtend(12) //-0011 12的反码,负数省略的位全部为1
```

实际上, 按位非(~)运算符要求其运算数为整型, 如果运算数不是整型, 它将和其他位运算符一样尝试将其转换为 32 位整型, 如果无法转换, 就返回 NaN. 那么 ~NaN 等于多少呢?

```js
console.log(
  ~(function() {
    alert(20)
  })()
) //先alert(20),然后输出-1
console.log(~'abc') //-1
console.log(~[]) //-1
console.log(~{}) //-1
console.log(~function() {}) //-1
console.log(~/\d/) //-1
console.log(~Infinity) //-1
console.log(~null) //-1
console.log(~undefined) //-1
console.log(~NaN) //-1
```

以上语句意在打印一个自执行函数的按位非运算结果. 而该自执行函数又没有显式指定返回值, 默认将返回 `undefined`. 因此它实际上是在输出 `~undefined` 的值. 而 `undefined` 值不能转换成整型, 通过测试运算结果为-1.

### 按位与

`&` 运算符用于连接两个数, 连接的两个数它们二进制补码形式的值每位都将参与运算, 只有相对应的位上都为 1 时, 该位的运算才返回 1. 比如 3 和 9 进行按位与运算, 以下是运算过程:

```js
0011 & 1001 //3的二进制补码形式 //9的二进制补码形式
--------------------0001 //1,相同位数依次运算,除最后一位都是1,返回1以外, 其它位数由于不同时为1都返回0
```

由上, 3&9 的运算结果为 1. 实际上, 由于按位与(&)运算同位上返回 1 的要求较为严苛, 因此, 它是一种趋向减小最大值的运算.(无论最大值是正数还是负数, 参与按位与运算后, 该数总是趋向减少二进制值位上 1 的数量, 因此总是有值减小的趋势. ) 对于按位与(&)运算, 满足如下规律:

1. 数值与自身或者 -1 按位与运算返回数值自身.

2. 2 的整数次方的值与它的相对数按位与运算返回它自身.

3. 任意整数与 0 进行按位与运算, 都将会返回 0.

4. 任意整数与 1 进行按位与运算, 都只有 0 或 1 两个返回值.

5. 按位与运算的结果不大于两数中的最大值.

我们可以对非整数取整, 即 `x&x === x&-1 === Math.trunc(x)`.

### 按位或

`|` 不同于 `&`, `|` 运算符连接的两个数, 只要其二进制补码形式的各位上有一个为 1, 该位的运算就返回 1, 否则返回 0. 比如 3 和 12 进行按位或运算, 以下是运算过程:

```js
0011 | 1100 //3的二进制补码形式 //12的二进制补码形式
--------------------1111 //15, 相同位数依次运算,遇1返回1,故最终结果为4个1.
```

由上, 3|12 的运算结果为 15. 实际上, 由于按位与(&)运算同位上返回 0 的要求较为严苛, 因此, 它是一种趋向增大最小值的运算. 对于按位或(|)运算, 满足如下规律:

1. 数值与自身按位或运算返回数值自身.

2. 2 的整数次方的值与它的相对数按位或运算返回它的相对数.

3. 任意整数与 0 进行按位或运算, 都将会返回它本身.

4. 任意整数与 -1 进行按位或运算, 都将返回 -1.

5. 按位或运算的结果不小于两数中的最小值.

我们便可以将非整数取整, 即 `x|0 === Math.trunc(x)`.

### 按位异或

`^` 运算符连接的两个数, 它们二进制补码形式的值每位参与运算, 只有相对应的每位值不同, 才返回 1, 否则返回 0. 如下:

```js
0011 ^ 1000 //3的二进制补码形式 //8的二进制补码形式
--------------------1011 //11, 相同位数依次运算, 值不同的返回1
```

对于按位异或(^)操作, 满足如下规律:

1. 由于按位异或位运算的特殊性, 数值与自身按位异或运算返回 0. 如: `8^8=0` , 公式为 `a^a=0` .

2. 任意整数与 0 进行按位异或运算, 都将会返回它本身. 如: `0^-98=-98` , 公式为 `a^0=a`.

3. 任意整数 x 与 1 进行按位异或运算, 若它为奇数, 则返回 `x-1` , 若它为偶数, 则返回 `x+1` . 如: `1^-9=-10` , `1^100=101` . 公式为 `1^奇=奇-1` , `1^偶=偶+1` ; 推而广之, 任意整数 x 与 2<sup>n</sup> 进行按位异或运算, 若它的二进制补码形式的倒数第 `n+1` 位是 1, 则返回 (x-2)<sup>n</sup>, 反之若为 0, 则返回 (x+2)<sup>n</sup> .

4. 任意整数 x 与 -1 进行按位异或运算, 则将返回 `-x-1` , 相当于 `~x` 运算 . 如: `-1^100=-101` , `-1^-9=8` . 公式为 `-1^x=-x-1=~x` .

5. 任意整数连续按位异或两次相同的数值, 返回它本身. 如: `3^8^8=3` , 公式为 `a^b^b=a` 或 `a^b^a=b` .

6. 按位异或满足操作数与运算结果 3 个数值之间的交换律: 按位异或的两个数值, 以及他们运算的结果, 共三个数值可以两两异或得到另外一个数值. 如: `3^9=10` , `3^10=9` , `9^10=3` ; 公式为 `a^b=c` , `a^c=b` , `b^c=a` .

### 有符号左移

`<<` 运算符, 表示将数值的 32 位二进制补码形式的除符号位之外的其他位都往左移动若干位数. 当 x 为整数时, 有: `x<<n === x*Math.pow(2,n)` 如下:

```js
console.log(1 << 3) //8
console.log(100 << 4) //1600
```

对于表达式 `x<<n`

- 当运算数 x 无法被转换为整数时，运算结果为 0.

  ```js
  console.log({} << 3) //0
  console.log(NaN << 2) //0
  ```

- 当运算数 n 无法被转换为整数时，运算结果为 x. 相当于 `x<<0` .

  ```js
  console.log(2 << NaN) //2
  ```

- 当运算数 x 和 n 均无法被转换为整数时，运算结果为 0.

  ```js
  console.log(NaN << NaN) //0
  ```

### 有符号右移

`>>` 运算符, 除了方向向右, 其他同 `<<` 运算符. 当 x 为整数时, 有: `x>>n === Math.floor(x*Math.pow(2,-n))` . 如下:

```js
console.log(-5 >> 2) //-2
console.log(-7 >> 3) //-1
```

右移负整数时, 返回值最大为 -1. 右移正整数时, 返回值最小为 0. 其他规律请参考 有符号左移时运算符之一为 NaN 的场景.

### 无符号右移

`>>>` 运算符, 表示连同符号也一起右移. 无符号右移(>>>)会把负数的二进制码当成正数的二进制码. 如下:

```js
console.log(-8 >>> 5) //134217727
console.log(-1 >>> 0) //4294967295
```

以上, 虽然-1 没有发生向右位移, 但是-1 的二进制码, 已经变成了正数的二进制码. 可见, -1 的二进制原码本就是 32 个 1, 将这 32 个 1 当正数的二进制处理, 直接还原成十进制. 我们来回顾下这个过程.

```js
translateAry(-1) //补全-1的二进制码至32位: 11111111111111111111111111111111
translateAry('11111111111111111111111111111111') //4294967295
```

### 运算优先级

| 优先级 |               运算符                |               描述               |
| :----: | :---------------------------------: | :------------------------------: |
|   1    |           a++,a--,[],(),.           | 后置++,后置--,数组下标,括号,属性 |
|   2    |            -,++a,--a,!,~            | 负号,前置++,前置--,逻辑非,按位非 |
|   3    |               \*,/,%                |           乘,除或取模            |
|   4    |                 +,-                 |            加减运算符            |
|   5    |                <<,>>                |            左移,右移             |
|   6    |              >,>=,<,<=              |            比较运算符            |
|   7    |                ==,!=                |            判断运算符            |
|   8    |                  &                  |              按位与              |
|   9    |                  ^                  |             按位异或             |
|   10   |                 \|                  |              按位或              |
|   11   |                 &&                  |              逻辑与              |
|   12   |                \|\|                 |              逻辑或              |
|   13   |                 ?:                  |            条件运算符            |
|   14   | =,/=,\*=,%=,+=,-=,<<=,>>=,&=,^=,\|= |            赋值运算符            |
|   15   |                  ,                  |               逗号               |

## 总结

综上可以总结出几条规律:

- 由于连接两个数值的位运算均是对相同的位进行比较操作, 故运算数值的先后位置并不重要, 这些位运算(& | ^)满足交换律. 即: `a 操作符 b === b 操作符 a`.

- 位运算中, 数字 0 和 1 都比较特殊. 记住它们的规律, 常可简化运算.

- 位运算(&|~^)可用于取整, 同 Math.trunc().

位运算一般只适用 `[-2^31, 2^31-1]` (即 -2147483648~2147483647) 以内的正负数. 超过这个范围, 计算将可能出现错误.由于数值 2^31 超过了 31 位(加上保留的一个符号位,共 32 位), 故计算出错, 于是就会按照负数的方式解释二进制的值.
