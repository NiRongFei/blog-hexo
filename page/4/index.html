<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/blog-hexo/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/blog-hexo/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/blog-hexo/images/favicon-16x16.ico"><link rel="mask-icon" href="/blog-hexo/images/logo.svg" color="#222"><link rel="stylesheet" href="/blog-hexo/css/main.css"><link rel="stylesheet" href="/blog-hexo/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.nirongfei.site",root:"/blog-hexo/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="知之真切笃实处即是行 行之明觉精察处即是知"><meta property="og:type" content="website"><meta property="og:title" content="阳明先生"><meta property="og:url" content="https://www.nirongfei.site/blog-hexo/page/4/index.html"><meta property="og:site_name" content="阳明先生"><meta property="og:description" content="知之真切笃实处即是行 行之明觉精察处即是知"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="阳明先生"><meta property="article:tag" content="阳明先生 知行合一 知之真切笃实处即是行 行之明觉精察处即是知"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.nirongfei.site/blog-hexo/page/4/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>阳明先生</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/blog-hexo/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">阳明先生</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">知行合一</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog-hexo/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/blog-hexo/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/blog-hexo/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/blog-hexo/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2017/05/27/others/170527/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2017/05/27/others/170527/" class="post-title-link" itemprop="url">计算机基础-算法基础</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-05-27 00:00:00" itemprop="dateCreated datePublished" datetime="2017-05-27T00:00:00+08:00">2017-05-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 15:57:12" itemprop="dateModified" datetime="2020-11-18T15:57:12+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E5%85%B6%E5%AE%83/" itemprop="url" rel="index"><span itemprop="name">其它</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>10k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>9 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>通常使用最差的时间复杂度来衡量一个算法的好坏。</p><p>常数时间 <code>O(1)</code> 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。</p><p>对于一个算法来说，可能会计算出如下操作次数 <code>a * n + 1</code>，<code>n</code> 代表数据量。那么该算法的时间复杂度就是 <code>O(n)</code>。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。</p><p>当然可能会出现两个算法都是 <code>O(n)</code> 的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了。</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>位运算在算法中很有用，速度可以比四则运算快很多。</p><p>在学习位运算之前应该知道十进制如何转二进制，二进制如何转十进制。这里说明下简单的计算方式：</p><ul><li>十进制 <code>33</code> 可以看成是 <code>32 + 1</code> ，并且 <code>33</code> 应该是六位二进制的（因为 <code>33</code> 近似 <code>32</code>，而 <code>32</code> 是 <code>2</code> 的五次方，所以是六位），那么 十进制 <code>33</code> 就是 <code>100001</code> ，只要是 <code>2</code> 的次方，那么就是 <code>1</code> 否则都为 <code>0</code></li><li>那么二进制 <code>100001</code> 同理，首位是 <code>2^5</code> ，末位是 <code>2^0</code> ，相加得出 <code>33</code></li></ul><h3 id="按位非"><a href="#按位非" class="headerlink" title="按位非 ~"></a>按位非 ~</h3><p>按位取反：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~<span class="number">8</span> <span class="comment">// -&gt; -9</span></span><br><span class="line"><span class="comment">// ~ 1000 -&gt; 0111 -&gt; -9</span></span><br></pre></td></tr></table></figure><h3 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与 &amp;"></a>按位与 &amp;</h3><p>对应位都为 1，结果才为 1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> &amp; <span class="number">7</span> <span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="comment">// 1000 &amp; 0111 -&gt; 0000 -&gt; 0</span></span><br></pre></td></tr></table></figure><h3 id="按位或"><a href="#按位或" class="headerlink" title="按位或 |"></a>按位或 |</h3><p>其中一位为 1，结果才为 1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> | <span class="number">7</span> <span class="comment">// -&gt; 15</span></span><br><span class="line"><span class="comment">// 1000 | 0111 -&gt; 1111 -&gt; 15</span></span><br></pre></td></tr></table></figure><h3 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或 ^"></a>按位异或 ^</h3><p>对应位不同，结果才为 1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> ^ <span class="number">7</span> <span class="comment">// -&gt; 15</span></span><br><span class="line"><span class="number">8</span> ^ <span class="number">8</span> <span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="comment">// 1000 ^ 0111 -&gt; 1111 -&gt; 15</span></span><br><span class="line"><span class="comment">// 1000 ^ 1000 -&gt; 0000 -&gt; 0</span></span><br></pre></td></tr></table></figure><blockquote><p>从以上代码中可以发现按位异或就是不进位加法。</p></blockquote><h3 id="算数左移-lt-lt"><a href="#算数左移-lt-lt" class="headerlink" title="算数左移 &lt;&lt;"></a>算数左移 &lt;&lt;</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> &lt;&lt; <span class="number">1</span> <span class="comment">// -&gt; 20</span></span><br></pre></td></tr></table></figure><p>左移就是将二进制全部往左移动，<code>10</code> 在二进制中表示为 <code>1010</code> ，左移一位后变成 <code>10100</code> ，转换为十进制也就是 <code>20</code>，所以基本可以把左移看成以下公式 <code>a * (2 ^ b)</code>。</p><h3 id="算数右移-gt-gt"><a href="#算数右移-gt-gt" class="headerlink" title="算数右移 &gt;&gt;"></a>算数右移 &gt;&gt;</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> &gt;&gt; <span class="number">1</span> <span class="comment">// -&gt; 5</span></span><br></pre></td></tr></table></figure><p>算数右移就是将二进制全部往右移动并去除多余的右边，<code>10</code> 在二进制中表示为 <code>1010</code> ，右移一位后变成 <code>101</code> ，转换为十进制也就是 <code>5</code>，所以基本可以把右移看成以下公式 <code>a / (2 ^ b)</code>。</p><blockquote><p>右移很好用，比如可以用在二分算法中取中间值。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span> &gt;&gt; <span class="number">1</span> <span class="comment">// -&gt; 6</span></span><br></pre></td></tr></table></figure><h3 id="逻辑右移-gt-gt-gt"><a href="#逻辑右移-gt-gt-gt" class="headerlink" title="逻辑右移 &gt;&gt;&gt;"></a>逻辑右移 &gt;&gt;&gt;</h3><p>逻辑右移表示连同符号也一起右移，无符号右移会把负数的二进制码当成正数的二进制码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span> &gt;&gt;&gt; <span class="number">0</span> <span class="comment">// -&gt; 4294967295</span></span><br></pre></td></tr></table></figure><p>虽然-1 没有发生向右位移, 但是-1 的二进制码, 已经变成了正数的二进制码。</p><p><strong>面试题</strong>：两个数不使用四则运算得出和</p><p>这道题中可以按位异或，因为按位异或就是不进位加法，<code>8 ^ 8 = 0</code> 如果进位了，就是 <code>16</code> 了，所以我们只需要将两个数进行异或操作，然后进位。那么也就是说两个二进制都是 <code>1</code> 的位置，左边应该有一个进位 <code>1</code>，所以可以得出以下公式 <code>a + b = (a ^ b) + ((a &amp; b) &lt;&lt; 1)</code> ，然后通过迭代的方式模拟加法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">let</span> newA = a ^ b</span><br><span class="line">  <span class="keyword">let</span> newB = (a &amp; b) &lt;&lt; <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> sum(newA, newB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>以下两个函数是排序中会用到的通用函数，就不一一写了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkArray</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!array || array.length &lt;= <span class="number">2</span>) <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rightValue = array[right]</span><br><span class="line">  array[right] = array[left]</span><br><span class="line">  array[left] = rightValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 <code>length - 1</code> 的位置。</p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" alt="冒泡排序"></p><p>以下是实现该算法的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  checkArray(array)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 从 0 到 `length - 1` 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) swap(array, j, j + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的操作次数是一个等差数列 <code>N + (N - 1) + (N- 2) + 1</code> ，去掉常数项以后得出时间复杂度是 <code>O(N^2)</code>。</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序的原理如下。第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作。</p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" alt="插入排序"></p><p>以下是实现该算法的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertion</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  checkArray(array)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; array[j + <span class="number">1</span>]; j--) swap(array, j, j + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的操作次数是一个等差数列 <code>N + (N - 1) + (N - 2) + 1</code> ，去掉常数项以后得出时间复杂度是 <code>O(N^2)</code>。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的原理如下。遍历数组，设置最小值的索引为 <code>0</code>，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值，下次遍历就可以从索引 <code>1</code> 开始重复上述操作。</p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" alt="选择排序"></p><p>以下是实现该算法的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selection</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  checkArray(array)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">      minIndex = array[j] &lt; array[minIndex] ? j : minIndex</span><br><span class="line">    &#125;</span><br><span class="line">    swap(array, i, minIndex)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的操作次数是一个等差数列 <code>N + (N - 1) + (N - 2) + 1</code> ，去掉常数项以后得出时间复杂度是 <code>O(N^2)</code>。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的原理如下。随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作。</p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif" alt="快速排序"></p><p>以下是实现该算法的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  checkArray(array);</span><br><span class="line">  quickSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    swap(array, , right)</span><br><span class="line">    <span class="comment">// 随机取值，然后和末尾交换，这样做比固定取一个位置的复杂度略低</span></span><br><span class="line">    <span class="keyword">let</span> indexs = part(array, <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * (right - left + <span class="number">1</span>)) + left, right);</span><br><span class="line">    quickSort(array, left, indexs[<span class="number">0</span>]);</span><br><span class="line">    quickSort(array, indexs[<span class="number">1</span>] + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">part</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> less = left - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> more = right;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; more) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[left] &lt; array[right]) &#123;</span><br><span class="line">      <span class="comment">// 当前值比基准值小，`less` 和 `left` 都加一</span></span><br><span class="line">	   ++less;</span><br><span class="line">       ++left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[left] &gt; array[right]) &#123;</span><br><span class="line">      <span class="comment">// 当前值比基准值大，将当前值和右边的值交换</span></span><br><span class="line">      <span class="comment">// 并且不改变 `left`，因为当前换过来的值还没有判断过大小</span></span><br><span class="line">      swap(array, --more, left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 和基准值相同，只移动下标</span></span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将基准值和比基准值大的第一个值交换位置</span></span><br><span class="line">  <span class="comment">// 这样数组就变成 `[比基准值小, 基准值, 比基准值大]`</span></span><br><span class="line">  swap(array, right, more);</span><br><span class="line">  <span class="keyword">return</span> [less, more];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的复杂度和归并排序是相同的，但是额外空间复杂度比归并排序少，只需 <code>O(logN)</code>。</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序的原理如下。递归的将数组两两分开直到最多包含两个元素，然后将数组排序合并，最终合并为排序好的数组。假设我有一组数组 <code>[3, 1, 2, 8, 9, 7, 6]</code>，中间数索引是 <code>3</code>，先排序数组 <code>[3, 1, 2, 8]</code> 。在这个左边数组上，继续拆分直到变成数组包含两个元素（如果数组长度是奇数的话，会有一个拆分数组只包含一个元素）。然后排序数组 <code>[3, 1]</code> 和 <code>[2, 8]</code> ，然后再排序数组 <code>[1, 3, 2, 8]</code> ，这样左边数组就排序完成，然后按照以上思路排序右边数组，最后将数组 <code>[1, 2, 3, 8]</code> 和 <code>[6, 7, 9]</code> 排序。</p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif" alt="归并排序"></p><p>以下是实现该算法的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  checkArray(array)</span><br><span class="line">  mergeSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 左右索引相同说明已经只有一个数</span></span><br><span class="line">  <span class="keyword">if</span> (left === right) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 等同于 `left + (right - left) / 2`</span></span><br><span class="line">  <span class="comment">// 相比 `(left + right) / 2` 来说更加安全，不会溢出</span></span><br><span class="line">  <span class="comment">// 使用位运算是因为位运算比四则运算快</span></span><br><span class="line">  <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>(left + ((right - left) &gt;&gt; <span class="number">1</span>))</span><br><span class="line">  mergeSort(array, left, mid)</span><br><span class="line">  mergeSort(array, mid + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> help = []</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> p1 = left</span><br><span class="line">  <span class="keyword">let</span> p2 = mid + <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;</span><br><span class="line">    help[i++] = array[p1] &lt; array[p2] ? array[p1++] : array[p2++]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">    help[i++] = array[p1++]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (p2 &lt;= right) &#123;</span><br><span class="line">    help[i++] = array[p2++]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">    array[left + i] = help[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上算法使用了递归的思想。递归的本质就是压栈，每递归执行一次函数，就将该函数的信息（比如参数，内部的变量，执行到的行数）压栈，直到遇到终止条件，然后出栈并继续执行函数。对于以上递归函数的调用轨迹如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mergeSort(data, <span class="number">0</span>, <span class="number">6</span>) <span class="comment">// mid = 3</span></span><br><span class="line">mergeSort(data, <span class="number">0</span>, <span class="number">3</span>) <span class="comment">// mid = 1</span></span><br><span class="line">mergeSort(data, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// mid = 0</span></span><br><span class="line">mergeSort(data, <span class="number">0</span>, <span class="number">0</span>) <span class="comment">// 遇到终止，回退到上一步</span></span><br><span class="line">mergeSort(data, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 遇到终止，回退到上一步</span></span><br><span class="line"><span class="comment">// 排序 p1 = 0, p2 = mid + 1 = 1</span></span><br><span class="line"><span class="comment">// 回退到 `mergeSort(data, 0, 3)` 执行下一个递归</span></span><br><span class="line">mergeSort(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// mid = 2</span></span><br><span class="line">mergeSort(<span class="number">3</span>, <span class="number">3</span>) <span class="comment">// 遇到终止，回退到上一步</span></span><br><span class="line"><span class="comment">// 排序 p1 = 2, p2 = mid + 1 = 3</span></span><br><span class="line"><span class="comment">// 回退到 `mergeSort(data, 0, 3)` 执行合并逻辑</span></span><br><span class="line"><span class="comment">// 排序 p1 = 0, p2 = mid + 1 = 2</span></span><br><span class="line"><span class="comment">// 执行完毕回退</span></span><br><span class="line"><span class="comment">// 左边数组排序完毕，右边也是如上轨迹</span></span><br></pre></td></tr></table></figure><p>该算法的操作次数是可以这样计算：递归了两次，每次数据量是数组的一半，并且最后把整个数组迭代了一次，所以得出表达式 <code>2T(N / 2) + T(N)</code> （T 代表时间，N 代表数据量）。根据该表达式可以套用 <a target="_blank" rel="noopener" href="https://www.wikiwand.com/zh-hans/%E4%B8%BB%E5%AE%9A%E7%90%86">该公式</a> 得出时间复杂度为 <code>O(NlogN)</code>。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序利用了二叉堆的特性来做，二叉堆通常用数组表示，并且二叉堆是一颗完全二叉树（所有叶节点（最底层的节点）都是从左往右顺序排序，并且其他层的节点都是满的）。二叉堆又分为大根堆与小根堆。</p><ul><li>大根堆是某个节点的所有子节点的值都比他小</li><li>小根堆是某个节点的所有子节点的值都比他大</li></ul><p>堆排序的原理就是组成一个大根堆或者小根堆。以小根堆为例，某个节点的左边子节点索引是 <code>i * 2 + 1</code>，右边是 <code>i * 2 + 2</code>，父节点是 <code>(i - 1) /2</code>。</p><ol><li>首先遍历数组，判断该节点的父节点是否比他小，如果小就交换位置并继续判断，直到他的父节点比他大</li><li>重新以上操作 1，直到数组首位是最大值</li><li>然后将首位和末尾交换位置并将数组长度减一，表示数组末尾已是最大值，不需要再比较大小</li><li>对比左右节点哪个大，然后记住大的节点的索引并且和父节点对比大小，如果子节点大就交换位置</li><li>重复以上操作 3 - 4 直到整个数组都是大根堆。</li></ol><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231308699-356134237.gif" alt="堆排序"></p><p>以下是实现该算法的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heap</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  checkArray(array)</span><br><span class="line">  <span class="comment">// 将最大值交换到首位</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    heapInsert(array, i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> size = array.length</span><br><span class="line">  <span class="comment">// 交换首位和末尾</span></span><br><span class="line">  swap(array, <span class="number">0</span>, --size)</span><br><span class="line">  <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    heapify(array, <span class="number">0</span>, size)</span><br><span class="line">    swap(array, <span class="number">0</span>, --size)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapInsert</span>(<span class="params">array, index</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果当前节点比父节点大，就交换</span></span><br><span class="line">  <span class="keyword">while</span> (array[index] &gt; array[<span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>)]) &#123;</span><br><span class="line">    swap(array, index, <span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>))</span><br><span class="line">    <span class="comment">// 将索引变成父节点</span></span><br><span class="line">    index = <span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">array, index, size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = index * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">    <span class="comment">// 判断左右节点大小</span></span><br><span class="line">    <span class="keyword">let</span> largest = left + <span class="number">1</span> &lt; size &amp;&amp; array[left] &lt; array[left + <span class="number">1</span>] ? left + <span class="number">1</span> : left</span><br><span class="line">    <span class="comment">// 判断子节点和父节点大小</span></span><br><span class="line">    largest = array[index] &lt; array[largest] ? largest : index</span><br><span class="line">    <span class="keyword">if</span> (largest === index) <span class="keyword">break</span></span><br><span class="line">    swap(array, index, largest)</span><br><span class="line">    index = largest</span><br><span class="line">    left = index * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码实现了小根堆，如果需要实现大根堆，只需要把节点对比反一下就好，该算法的复杂度是 <code>O(NlogN)</code>。</p><h3 id="系统排序"><a href="#系统排序" class="headerlink" title="系统排序"></a>系统排序</h3><p>每个语言的排序内部实现都是不同的。</p><p>对于 JS 来说，数组长度大于 <code>10</code> 会采用快排，否则使用插入排序 <a target="_blank" rel="noopener" href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js##L760:7">源码实现</a> 。选择插入排序是因为虽然时间复杂度很差，但是在数据量很小的情况下和 <code>O(N * logN)</code> 相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。</p><p>对于 Java 来说，还会考虑内部的元素的类型。对于存储对象的数组来说，会采用稳定性好的算法。稳定性的意思就是对于相同值来说，相对顺序不能改变。</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉遍历"><a href="#二叉遍历" class="headerlink" title="二叉遍历"></a>二叉遍历</h3><ol><li><p>先序遍历表示先访问根节点，然后访问左节点，最后访问右节点。</p></li><li><p>中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。</p></li><li><p>后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。</p></li></ol><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><p>递归实现相当简单，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.val = val</span><br><span class="line">  <span class="built_in">this</span>.left = <span class="built_in">this</span>.right = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> traversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="comment">// 先序</span></span><br><span class="line">    <span class="built_in">console</span>.log(root)</span><br><span class="line">    traversal(root.left)</span><br><span class="line">    <span class="comment">// 中序</span></span><br><span class="line">    <span class="comment">// console.log(root);</span></span><br><span class="line">    traversal(root.right)</span><br><span class="line">    <span class="comment">// 后序</span></span><br><span class="line">    <span class="comment">// console.log(root);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于递归的实现来说，只需要理解每个节点都会被访问三次就明白为什么这样实现了。</p><h4 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h4><p>非递归实现使用了栈的结构，通过栈的先进后出模拟递归实现。</p><p>以下是先序遍历代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pre</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="comment">// 先将根节点 push</span></span><br><span class="line">    stack.push(root)</span><br><span class="line">    <span class="comment">// 判断栈中是否为空</span></span><br><span class="line">    <span class="keyword">while</span> (stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">      root = stack.pop()</span><br><span class="line">      <span class="built_in">console</span>.log(root)</span><br><span class="line">      <span class="comment">// 因为先序遍历是先左后右，栈是先进后出结构</span></span><br><span class="line">      <span class="comment">// 所以先 push 右边再 push 左边</span></span><br><span class="line">      <span class="keyword">if</span> (root.right) &#123;</span><br><span class="line">        stack.push(root.right)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root.left) &#123;</span><br><span class="line">        stack.push(root.left)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是中序遍历代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mid</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="comment">// 中序遍历是先左再根最后右</span></span><br><span class="line">    <span class="comment">// 所以首先应该先把最左边节点遍历到底依次 push 进栈</span></span><br><span class="line">    <span class="comment">// 当左边没有节点时，就打印栈顶元素，然后寻找右节点</span></span><br><span class="line">    <span class="comment">// 对于最左边的叶节点来说，可以把它看成是两个 null 节点的父节点</span></span><br><span class="line">    <span class="comment">// 左边打印不出东西就把父节点拿出来打印，然后再看右节点</span></span><br><span class="line">    <span class="keyword">while</span> (stack.length &gt; <span class="number">0</span> || root) &#123;</span><br><span class="line">      <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        stack.push(root)</span><br><span class="line">        root = root.left</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root = stack.pop()</span><br><span class="line">        <span class="built_in">console</span>.log(root)</span><br><span class="line">        root = root.right</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是后序遍历代码实现，该代码使用了两个栈来实现遍历，相比一个栈的遍历来说要容易理解很多：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pos</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack1 = []</span><br><span class="line">    <span class="keyword">let</span> stack2 = []</span><br><span class="line">    <span class="comment">// 后序遍历是先左再右最后根</span></span><br><span class="line">    <span class="comment">// 所以对于一个栈来说，应该先 push 根节点</span></span><br><span class="line">    <span class="comment">// 然后 push 右节点，最后 push 左节点</span></span><br><span class="line">    stack1.push(root)</span><br><span class="line">    <span class="keyword">while</span> (stack1.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      root = stack1.pop()</span><br><span class="line">      stack2.push(root)</span><br><span class="line">      <span class="keyword">if</span> (root.left) &#123;</span><br><span class="line">        stack1.push(root.left)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root.right) &#123;</span><br><span class="line">        stack1.push(root.right)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (stack2.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(s2.pop())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历节点"><a href="#中序遍历节点" class="headerlink" title="中序遍历节点"></a>中序遍历节点</h3><p>实现这个算法的前提是节点有一个 <code>parent</code> 的指针指向父节点，根节点指向 <code>null</code>：</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/24/162f61ad8e8588b7?w=682&h=486&f=png&s=41027"></p><h4 id="前驱节点"><a href="#前驱节点" class="headerlink" title="前驱节点"></a>前驱节点</h4><p>对于节点 <code>2</code> 来说，他的前驱节点就是 <code>4</code> ，按照中序遍历原则，可以得出以下结论</p><ol><li>如果选取的节点的左节点不为空，就找该左节点最右的节点。对于节点 <code>1</code> 来说，他有左节点 <code>2</code> ，那么节点 <code>2</code> 的最右节点就是 <code>5</code></li><li>如果左节点为空，且目标节点是父节点的右节点，那么前驱节点为父节点。对于节点 <code>5</code> 来说，没有左节点，且是节点 <code>2</code> 的右节点，所以节点 <code>2</code> 是前驱节点</li><li>如果左节点为空，且目标节点是父节点的左节点，向上寻找到第一个是父节点的右节点的节点。对于节点 <code>6</code> 来说，没有左节点，且是节点 <code>3</code> 的左节点，所以向上寻找到节点 <code>1</code> ，发现节点 <code>3</code> 是节点 1 的右节点，所以节点 <code>1</code> 是节点 <code>6</code> 的前驱节点</li></ol><p>以下是算法实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">predecessor</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 结论 1</span></span><br><span class="line">  <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">    <span class="keyword">return</span> getRight(node.left)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> parent = node.parent</span><br><span class="line">    <span class="comment">// 结论 2 3 的判断</span></span><br><span class="line">    <span class="keyword">while</span> (parent &amp;&amp; parent.right === node) &#123;</span><br><span class="line">      node = parent</span><br><span class="line">      parent = node.parent</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRight</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span></span><br><span class="line">  node = node.right</span><br><span class="line">  <span class="keyword">while</span> (node) node = node.right</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后继节点"><a href="#后继节点" class="headerlink" title="后继节点"></a>后继节点</h4><p>对于节点 <code>2</code> 来说，他的后继节点就是 <code>5</code> ，按照中序遍历原则，可以得出以下结论：</p><ol><li>如果有右节点，就找到该右节点的最左节点。对于节点 <code>1</code> 来说，他有右节点 <code>3</code> ，那么节点 <code>3</code> 的最左节点就是 <code>6</code></li><li>如果没有右节点，就向上遍历直到找到一个节点是父节点的左节点。对于节点 <code>5</code> 来说，没有右节点，就向上寻找到节点 <code>2</code> ，该节点是父节点 <code>1</code> 的左节点，所以节点 <code>1</code> 是后继节点</li></ol><p>以下是算法实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">successor</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 结论 1</span></span><br><span class="line">  <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">    <span class="keyword">return</span> getLeft(node.right)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 结论 2</span></span><br><span class="line">    <span class="keyword">let</span> parent = node.parent</span><br><span class="line">    <span class="comment">// 判断 parent 为空</span></span><br><span class="line">    <span class="keyword">while</span> (parent &amp;&amp; parent.left === node) &#123;</span><br><span class="line">      node = parent</span><br><span class="line">      parent = node.parent</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLeft</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span></span><br><span class="line">  node = node.left</span><br><span class="line">  <span class="keyword">while</span> (node) node = node.left</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树的深度"><a href="#树的深度" class="headerlink" title="树的深度"></a>树的深度</h3><p>树的最大深度：该题目来自 <a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/">Leetcode</a>，题目需要求出一颗二叉树的最大深度</p><p>以下是算法实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于该递归函数可以这样理解：一旦没有找到节点就会返回 <code>0</code>，每弹出一次递归函数就会加 <code>1</code>，树有三层就会得到 <code>3</code>。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2017/05/16/others/170516/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2017/05/16/others/170516/" class="post-title-link" itemprop="url">计算机基础-数据结构</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-05-16 00:00:00" itemprop="dateCreated datePublished" datetime="2017-05-16T00:00:00+08:00">2017-05-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 15:57:12" itemprop="dateModified" datetime="2020-11-18T15:57:12+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E5%85%B6%E5%AE%83/" itemprop="url" rel="index"><span itemprop="name">其它</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>14k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>13 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>栈是一个线性结构，在计算机中是一个相当常见的数据结构，栈的特点是只能在某一端添加或删除数据，遵循先进后出的原则。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>每种数据结构都可以用很多种方式来实现，其实可以把栈看成是数组的一个子集，所以这里使用数组来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stack = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stack.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stack.pop()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack[<span class="built_in">this</span>.getCount() - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getCount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack.length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getCount() === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>选取了 <a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-parentheses/submissions/1">LeetCode 第 20 题</a>，题意是匹配括号，可以通过栈的特性来完成这道题目：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;</span><br><span class="line">    <span class="string">&#x27;(&#x27;</span>: -<span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;)&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;[&#x27;</span>: -<span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;]&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;&#123;&#x27;</span>: -<span class="number">3</span>,</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> stack = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map[s[i]] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      stack.push(s[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> last = stack.pop()</span><br><span class="line">      <span class="keyword">if</span> (map[last] + map[s[i]] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stack.length &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>队列是一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>这里会讲解两种实现队列的方式，分别是单链队列和循环队列。</p><h4 id="单链队列"><a href="#单链队列" class="headerlink" title="单链队列"></a>单链队列</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.queue = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">enQueue</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.queue.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">deQueue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.queue.shift()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getHeader</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.queue[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getLength</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getLength() === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为单链队列在出队操作的时候需要 <code>O(n)</code> 的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是 <code>O(1)</code> 的时间复杂度。</p><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqQueue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="built_in">Array</span>(length + <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 队头</span></span><br><span class="line">    <span class="built_in">this</span>.first = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 队尾</span></span><br><span class="line">    <span class="built_in">this</span>.last = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 当前队列大小</span></span><br><span class="line">    <span class="built_in">this</span>.size = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">enQueue</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断队尾 + 1 是否为队头</span></span><br><span class="line">    <span class="comment">// 如果是就代表需要扩容数组</span></span><br><span class="line">    <span class="comment">// % this.queue.length 是为了防止数组越界</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.first === (<span class="built_in">this</span>.last + <span class="number">1</span>) % <span class="built_in">this</span>.queue.length) &#123;</span><br><span class="line">      <span class="built_in">this</span>.resize(<span class="built_in">this</span>.getLength() * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.queue[<span class="built_in">this</span>.last] = item</span><br><span class="line">    <span class="built_in">this</span>.size++</span><br><span class="line">    <span class="built_in">this</span>.last = (<span class="built_in">this</span>.last + <span class="number">1</span>) % <span class="built_in">this</span>.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">deQueue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;Queue is empty&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="built_in">this</span>.queue[<span class="built_in">this</span>.first]</span><br><span class="line">    <span class="built_in">this</span>.queue[<span class="built_in">this</span>.first] = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.first = (<span class="built_in">this</span>.first + <span class="number">1</span>) % <span class="built_in">this</span>.queue.length</span><br><span class="line">    <span class="built_in">this</span>.size--</span><br><span class="line">    <span class="comment">// 判断当前队列大小是否过小</span></span><br><span class="line">    <span class="comment">// 为了保证不浪费空间，在队列空间等于总长度四分之一时</span></span><br><span class="line">    <span class="comment">// 且不为 2 时缩小总长度为当前的一半</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.size === <span class="built_in">this</span>.getLength() / <span class="number">4</span> &amp;&amp; <span class="built_in">this</span>.getLength() / <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.resize(<span class="built_in">this</span>.getLength() / <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getHeader</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;Queue is empty&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.queue[<span class="built_in">this</span>.first]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getLength</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.queue.length - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.first === <span class="built_in">this</span>.last</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">resize</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> q = <span class="keyword">new</span> <span class="built_in">Array</span>(length)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      q[i] = <span class="built_in">this</span>.queue[(i + <span class="built_in">this</span>.first) % <span class="built_in">this</span>.queue.length]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.queue = q</span><br><span class="line">    <span class="built_in">this</span>.first = <span class="number">0</span></span><br><span class="line">    <span class="built_in">this</span>.last = <span class="built_in">this</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>单向链表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">v, next</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = v</span><br><span class="line">    <span class="built_in">this</span>.next = next</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 链表长度</span></span><br><span class="line">    <span class="built_in">this</span>.size = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 虚拟头部</span></span><br><span class="line">    <span class="built_in">this</span>.dummyNode = <span class="keyword">new</span> Node(<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">find</span>(<span class="params">header, index, currentIndex</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === currentIndex) <span class="keyword">return</span> header</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.find(header.next, index, currentIndex + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addNode</span>(<span class="params">v, index</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.checkIndex(index)</span><br><span class="line">    <span class="comment">// 当往链表末尾插入时，prev.next 为空</span></span><br><span class="line">    <span class="comment">// 其他情况时，因为要插入节点，所以插入的节点</span></span><br><span class="line">    <span class="comment">// 的 next 应该是 prev.next</span></span><br><span class="line">    <span class="comment">// 然后设置 prev.next 为插入的节点</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="built_in">this</span>.find(<span class="built_in">this</span>.dummyNode, index, <span class="number">0</span>)</span><br><span class="line">    prev.next = <span class="keyword">new</span> Node(v, prev.next)</span><br><span class="line">    <span class="built_in">this</span>.size++</span><br><span class="line">    <span class="keyword">return</span> prev.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">insertNode</span>(<span class="params">v, index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.addNode(v, index)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addToFirst</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.addNode(v, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addToLast</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.addNode(v, <span class="built_in">this</span>.size)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">removeNode</span>(<span class="params">index, isLast</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.checkIndex(index)</span><br><span class="line">    index = isLast ? index - <span class="number">1</span> : index</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="built_in">this</span>.find(<span class="built_in">this</span>.dummyNode, index, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> node = prev.next</span><br><span class="line">    prev.next = node.next</span><br><span class="line">    node.next = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.size--</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">removeFirstNode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.removeNode(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">removeLastNode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.removeNode(<span class="built_in">this</span>.size, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">checkIndex</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="built_in">this</span>.size) <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;Index error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getNode</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.checkIndex(index)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.find(<span class="built_in">this</span>.dummyNode, index, <span class="number">0</span>).next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getSize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。</p><p>二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树。</p><h4 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h4><p>二分搜索树也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小。</p><p>这种存储方式很适合于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率。</p><p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043735.png" alt="二分搜索树"></p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.size = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getSize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addNode</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="built_in">this</span>._addChild(<span class="built_in">this</span>.root, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加节点时，需要比较添加的节点值和当前</span></span><br><span class="line">  <span class="comment">// 节点值的大小</span></span><br><span class="line">  <span class="function"><span class="title">_addChild</span>(<span class="params">node, v</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      <span class="built_in">this</span>.size++</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">      node.left = <span class="built_in">this</span>._addChild(node.left, v)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">      node.right = <span class="built_in">this</span>._addChild(node.right, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是最基本的二分搜索树实现，接下来实现树的遍历。</p><p>对于树的遍历来说，有三种遍历方法，分别是先序遍历、中序遍历、后序遍历。三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树。如果需要实现先序遍历，那么只需要第一次遍历到节点时进行操作即可。</p><p>以下都是递归实现，如果你想学习非递归实现，可以 <a target="_blank" rel="noopener" href="https://yuchengkai.cn/docs/Algorithm/algorithm-ch.html##%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0">点击这里阅读</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历可用于打印树的结构</span></span><br><span class="line"><span class="comment">// 先序遍历先访问根节点，然后访问左节点，最后访问右节点。</span></span><br><span class="line"><span class="function"><span class="title">preTraversal</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>._pre(<span class="built_in">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_pre</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">    <span class="built_in">this</span>._pre(node.left)</span><br><span class="line">    <span class="built_in">this</span>._pre(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历可用于排序</span></span><br><span class="line"><span class="comment">// 对于 BST 来说，中序遍历可以实现一次遍历就</span></span><br><span class="line"><span class="comment">// 得到有序的值</span></span><br><span class="line"><span class="comment">// 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。</span></span><br><span class="line"><span class="function"><span class="title">midTraversal</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>._mid(<span class="built_in">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_mid</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="built_in">this</span>._mid(node.left)</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">    <span class="built_in">this</span>._mid(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历可用于先操作子节点</span></span><br><span class="line"><span class="comment">// 再操作父节点的场景</span></span><br><span class="line"><span class="comment">// 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。</span></span><br><span class="line"><span class="function"><span class="title">backTraversal</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>._back(<span class="built_in">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_back</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="built_in">this</span>._back(node.left)</span><br><span class="line">    <span class="built_in">this</span>._back(node.right)</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的这几种遍历都可以称之为深度遍历，对应的还有种遍历叫做广度遍历，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">breadthTraversal</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.root) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> q = <span class="keyword">new</span> Queue()</span><br><span class="line">  <span class="comment">// 将根节点入队</span></span><br><span class="line">  q.enQueue(<span class="built_in">this</span>.root)</span><br><span class="line">  <span class="comment">// 循环判断队列是否为空，为空</span></span><br><span class="line">  <span class="comment">// 代表树遍历完毕</span></span><br><span class="line">  <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 将队首出队，判断是否有左右子树</span></span><br><span class="line">    <span class="comment">// 有的话，就先左后右入队</span></span><br><span class="line">    <span class="keyword">let</span> n = q.deQueue()</span><br><span class="line">    <span class="built_in">console</span>.log(n.value)</span><br><span class="line">    <span class="keyword">if</span> (n.left) q.enQueue(n.left)</span><br><span class="line">    <span class="keyword">if</span> (n.right) q.enQueue(n.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来先介绍如何在树中寻找最小值或最大数。因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getMin</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>._getMin(<span class="built_in">this</span>.root).value</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_getMin</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.left) <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>._getMin(node.left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">getMax</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>._getMax(<span class="built_in">this</span>.root).value</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_getMax</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.right) <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>._getMin(node.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>向上取整和向下取整</strong>这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。既然是向下取整，那么根据二分搜索树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树。如果有的话，继续上面的递归判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">floor</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="built_in">this</span>._floor(<span class="built_in">this</span>.root, v)</span><br><span class="line">  <span class="keyword">return</span> node ? node.value : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_floor</span>(<span class="params">node, v</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (node.value === v) <span class="keyword">return</span> v</span><br><span class="line">  <span class="comment">// 如果当前节点值还比需要的值大，就继续递归</span></span><br><span class="line">  <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._floor(node.left, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断当前节点是否拥有右子树</span></span><br><span class="line">  <span class="keyword">let</span> right = <span class="built_in">this</span>._floor(node.right, v)</span><br><span class="line">  <span class="keyword">if</span> (right) <span class="keyword">return</span> right</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>排名</strong>是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个 <code>size</code> 属性。该属性表示该节点下有多少子节点（包含自身）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    <span class="built_in">this</span>.size = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增代码</span></span><br><span class="line"><span class="function"><span class="title">_getSize</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> node ? node.size : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_addChild</span>(<span class="params">node, v</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    node.size++</span><br><span class="line">    node.left = <span class="built_in">this</span>._addChild(node.left, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    node.size++</span><br><span class="line">    node.right = <span class="built_in">this</span>._addChild(node.right, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">select</span>(<span class="params">k</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="built_in">this</span>._select(<span class="built_in">this</span>.root, k)</span><br><span class="line">  <span class="keyword">return</span> node ? node.value : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_select</span>(<span class="params">node, k</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 先获取左子树下有几个节点</span></span><br><span class="line">  <span class="keyword">let</span> size = node.left ? node.left.size : <span class="number">0</span></span><br><span class="line">  <span class="comment">// 判断 size 是否大于 k</span></span><br><span class="line">  <span class="comment">// 如果大于 k，代表所需要的节点在左节点</span></span><br><span class="line">  <span class="keyword">if</span> (size &gt; k) <span class="keyword">return</span> <span class="built_in">this</span>._select(node.left, k)</span><br><span class="line">  <span class="comment">// 如果小于 k，代表所需要的节点在右节点</span></span><br><span class="line">  <span class="comment">// 注意这里需要重新计算 k，减去根节点除了右子树的节点数量</span></span><br><span class="line">  <span class="keyword">if</span> (size &lt; k) <span class="keyword">return</span> <span class="built_in">this</span>._select(node.right, k - size - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是二分搜索树中最难实现的部分：删除节点。因为对于删除节点来说，会存在以下几种情况：</p><ul><li>需要删除的节点没有子树</li><li>需要删除的节点只有一条子树</li><li>需要删除的节点有左右两条树</li></ul><p>对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删除最小节点，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">delectMin</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.root = <span class="built_in">this</span>._delectMin(<span class="built_in">this</span>.root)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_delectMin</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 一直递归左子树</span></span><br><span class="line">  <span class="comment">// 如果左子树为空，就判断节点是否拥有右子树</span></span><br><span class="line">  <span class="comment">// 有右子树的话就把需要删除的节点替换为右子树</span></span><br><span class="line">  <span class="keyword">if</span> ((node != <span class="literal">null</span>) &amp; !node.left) <span class="keyword">return</span> node.right</span><br><span class="line">  node.left = <span class="built_in">this</span>._delectMin(node.left)</span><br><span class="line">  <span class="comment">// 最后需要重新维护下节点的 `size`</span></span><br><span class="line">  node.size = <span class="built_in">this</span>._getSize(node.left) + <span class="built_in">this</span>._getSize(node.right) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是如何删除任意节点了，当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。</p><p>你如果对于这个解决办法有疑问的话，可以这样考虑。因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">delect</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.root = <span class="built_in">this</span>._delect(<span class="built_in">this</span>.root, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_delect</span>(<span class="params">node, v</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 寻找的节点比当前节点小，去左子树找</span></span><br><span class="line">  <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">    node.right = <span class="built_in">this</span>._delect(node.right, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">    <span class="comment">// 寻找的节点比当前节点大，去右子树找</span></span><br><span class="line">    node.left = <span class="built_in">this</span>._delect(node.left, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 进入这个条件说明已经找到节点</span></span><br><span class="line">    <span class="comment">// 先判断节点是否拥有拥有左右子树中的一个</span></span><br><span class="line">    <span class="comment">// 是的话，将子树返回出去，这里和 `_delectMin` 的操作一样</span></span><br><span class="line">    <span class="keyword">if</span> (!node.left) <span class="keyword">return</span> node.right</span><br><span class="line">    <span class="keyword">if</span> (!node.right) <span class="keyword">return</span> node.left</span><br><span class="line">    <span class="comment">// 进入这里，代表节点拥有左右子树</span></span><br><span class="line">    <span class="comment">// 先取出当前节点的后继结点，也就是取当前节点右子树的最小值</span></span><br><span class="line">    <span class="keyword">let</span> min = <span class="built_in">this</span>._getMin(node.right)</span><br><span class="line">    <span class="comment">// 取出最小值后，删除最小值</span></span><br><span class="line">    <span class="comment">// 然后把删除节点后的子树赋值给最小值节点</span></span><br><span class="line">    min.right = <span class="built_in">this</span>._delectMin(node.right)</span><br><span class="line">    <span class="comment">// 左子树不动</span></span><br><span class="line">    min.left = node.left</span><br><span class="line">    node = min</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 维护 size</span></span><br><span class="line">  node.size = <span class="built_in">this</span>._getSize(node.left) + <span class="built_in">this</span>._getSize(node.right) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>二分搜索树实际在业务中是受到限制的，因为并不是严格的 <code>O(logN)</code>，在极端情况下会退化成链表，比如加入一组升序的数字就会造成这种情况。</p><p>AVL 树改进了二分搜索树，在 AVL 树中任意节点的左右子树的高度差都不大于 <code>1</code>，这样保证了时间复杂度是严格的 <code>O(logN)</code>。基于此，对 AVL 树增加或删除节点时可能需要旋转树来达到高度的平衡。</p><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>因为 AVL 树是改进了二分搜索树，所以部分代码是于二分搜索树重复的，对于重复内容不作再次解析。</p><p>对于 AVL 树来说，添加节点会有四种情况</p><p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-43736.png" alt="AVL树"></p><p>对于左左情况来说，新增加的节点位于节点 <code>2</code> 的左侧，这时树已经不平衡，需要旋转。因为搜索树的特性，节点比左节点大，比右节点小，所以旋转以后也要实现这个特性。</p><p>旋转之前：<code>new &lt; 2 &lt; C &lt; 3 &lt; B &lt; 5 &lt; A</code>，右旋之后节点 <code>3</code> 为根节点，这时候需要将节点 <code>3</code> 的右节点加到节点 <code>5</code> 的左边，最后还需要更新节点的高度。</p><p>对于右右情况来说，相反于左左情况，所以不再赘述。</p><p>对于左右情况来说，新增加的节点位于节点 <code>4</code> 的右侧。对于这种情况，需要通过两次旋转来达到目的。</p><p>首先对节点的左节点左旋，这时树满足左左的情况，再对节点进行一次右旋就可以达到目的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.height = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVL</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addNode</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="built_in">this</span>._addChild(<span class="built_in">this</span>.root, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_addChild</span>(<span class="params">node, v</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">      node.left = <span class="built_in">this</span>._addChild(node.left, v)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">      node.right = <span class="built_in">this</span>._addChild(node.right, v)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.value = v</span><br><span class="line">    &#125;</span><br><span class="line">    node.height = <span class="number">1</span> + <span class="built_in">Math</span>.max(<span class="built_in">this</span>._getHeight(node.left), <span class="built_in">this</span>._getHeight(node.right))</span><br><span class="line">    <span class="keyword">let</span> factor = <span class="built_in">this</span>._getBalanceFactor(node)</span><br><span class="line">    <span class="comment">// 当需要右旋时，根节点的左树一定比右树高度高</span></span><br><span class="line">    <span class="keyword">if</span> (factor &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">this</span>._getBalanceFactor(node.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._rightRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当需要左旋时，根节点的左树一定比右树高度矮</span></span><br><span class="line">    <span class="keyword">if</span> (factor &lt; -<span class="number">1</span> &amp;&amp; <span class="built_in">this</span>._getBalanceFactor(node.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._leftRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右情况</span></span><br><span class="line">    <span class="comment">// 节点的左树比右树高，且节点的左树的右树比节点的左树的左树高</span></span><br><span class="line">    <span class="keyword">if</span> (factor &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">this</span>._getBalanceFactor(node.left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      node.left = <span class="built_in">this</span>._leftRotate(node.left)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._rightRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右左情况</span></span><br><span class="line">    <span class="comment">// 节点的左树比右树矮，且节点的右树的右树比节点的右树的左树矮</span></span><br><span class="line">    <span class="keyword">if</span> (factor &lt; -<span class="number">1</span> &amp;&amp; <span class="built_in">this</span>._getBalanceFactor(node.right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      node.right = <span class="built_in">this</span>._rightRotate(node.right)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._leftRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_getHeight</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> node.height</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_getBalanceFactor</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._getHeight(node.left) - <span class="built_in">this</span>._getHeight(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 节点右旋</span></span><br><span class="line">  <span class="comment">//           5                    2</span></span><br><span class="line">  <span class="comment">//         /   \                /   \</span></span><br><span class="line">  <span class="comment">//        2     6   ==&gt;       1      5</span></span><br><span class="line">  <span class="comment">//       /  \               /       /  \</span></span><br><span class="line">  <span class="comment">//      1    3             new     3    6</span></span><br><span class="line">  <span class="comment">//     /</span></span><br><span class="line">  <span class="comment">//    new</span></span><br><span class="line">  <span class="function"><span class="title">_rightRotate</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 旋转后新根节点</span></span><br><span class="line">    <span class="keyword">let</span> newRoot = node.left</span><br><span class="line">    <span class="comment">// 需要移动的节点</span></span><br><span class="line">    <span class="keyword">let</span> moveNode = newRoot.right</span><br><span class="line">    <span class="comment">// 节点 2 的右节点改为节点 5</span></span><br><span class="line">    newRoot.right = node</span><br><span class="line">    <span class="comment">// 节点 5 左节点改为节点 3</span></span><br><span class="line">    node.left = moveNode</span><br><span class="line">    <span class="comment">// 更新树的高度</span></span><br><span class="line">    node.height = <span class="number">1</span> + <span class="built_in">Math</span>.max(<span class="built_in">this</span>._getHeight(node.left), <span class="built_in">this</span>._getHeight(node.right))</span><br><span class="line">    newRoot.height = <span class="number">1</span> + <span class="built_in">Math</span>.max(<span class="built_in">this</span>._getHeight(newRoot.left), <span class="built_in">this</span>._getHeight(newRoot.right))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRoot</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 节点左旋</span></span><br><span class="line">  <span class="comment">//           4                    6</span></span><br><span class="line">  <span class="comment">//         /   \                /   \</span></span><br><span class="line">  <span class="comment">//        2     6   ==&gt;       4      7</span></span><br><span class="line">  <span class="comment">//             /  \         /   \      \</span></span><br><span class="line">  <span class="comment">//            5     7      2     5      new</span></span><br><span class="line">  <span class="comment">//                   \</span></span><br><span class="line">  <span class="comment">//                    new</span></span><br><span class="line">  <span class="function"><span class="title">_leftRotate</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 旋转后新根节点</span></span><br><span class="line">    <span class="keyword">let</span> newRoot = node.right</span><br><span class="line">    <span class="comment">// 需要移动的节点</span></span><br><span class="line">    <span class="keyword">let</span> moveNode = newRoot.left</span><br><span class="line">    <span class="comment">// 节点 6 的左节点改为节点 4</span></span><br><span class="line">    newRoot.left = node</span><br><span class="line">    <span class="comment">// 节点 4 右节点改为节点 5</span></span><br><span class="line">    node.right = moveNode</span><br><span class="line">    <span class="comment">// 更新树的高度</span></span><br><span class="line">    node.height = <span class="number">1</span> + <span class="built_in">Math</span>.max(<span class="built_in">this</span>._getHeight(node.left), <span class="built_in">this</span>._getHeight(node.right))</span><br><span class="line">    newRoot.height = <span class="number">1</span> + <span class="built_in">Math</span>.max(<span class="built_in">this</span>._getHeight(newRoot.left), <span class="built_in">this</span>._getHeight(newRoot.right))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRoot</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>堆通常是一个可以被看做一棵树的数组对象。</p><p>堆的实现通过构造<strong>二叉堆</strong>，实为二叉树的一种。这种数据结构具有以下性质。</p><ul><li>任意节点小于（或大于）它的所有子节点</li><li>堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填入。</li></ul><p>将根节点最大的堆叫做<strong>最大堆</strong>或<strong>大根堆</strong>，根节点最小的堆叫做<strong>最小堆</strong>或<strong>小根堆</strong>。</p><p>优先队列也完全可以用堆来实现，操作是一模一样的。</p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><p>堆的每个节点的左边子节点索引是 <code>i * 2 + 1</code>，右边是 <code>i * 2 + 2</code>，父节点是 <code>(i - 1) /2</code>。</p><p>堆有两个核心的操作，分别是 <code>shiftUp</code> 和 <code>shiftDown</code> 。前者用于添加元素，后者用于删除根节点。</p><ul><li><code>shiftUp</code> 的核心思路是一路将节点与父节点对比大小，如果比父节点大，就和父节点交换位置。</li><li><code>shiftDown</code> 的核心思路是先将根节点和末尾交换位置，然后移除末尾元素。接下来循环判断父节点和两个子节点的大小，如果子节点大，就把最大的子节点和父节点交换。</li></ul><p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043738.png" alt="大根堆"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.heap = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.heap.length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">empty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size() == <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.heap.push(item)</span><br><span class="line">    <span class="built_in">this</span>._shiftUp(<span class="built_in">this</span>.size() - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">removeMax</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._shiftDown(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getParentIndex</span>(<span class="params">k</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>((k - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getLeftIndex</span>(<span class="params">k</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> k * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_shiftUp</span>(<span class="params">k</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前节点比父节点大，就交换</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.heap[k] &gt; <span class="built_in">this</span>.heap[<span class="built_in">this</span>.getParentIndex(k)]) &#123;</span><br><span class="line">      <span class="built_in">this</span>._swap(k, <span class="built_in">this</span>.getParentIndex(k))</span><br><span class="line">      <span class="comment">// 将索引变成父节点</span></span><br><span class="line">      k = <span class="built_in">this</span>.getParentIndex(k)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_shiftDown</span>(<span class="params">k</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 交换首位并删除末尾</span></span><br><span class="line">    <span class="built_in">this</span>._swap(k, <span class="built_in">this</span>.size() - <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">this</span>.heap.splice(<span class="built_in">this</span>.size() - <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 判断节点是否有左孩子，因为二叉堆的特性，有右必有左</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.getLeftIndex(k) &lt; <span class="built_in">this</span>.size()) &#123;</span><br><span class="line">      <span class="keyword">let</span> j = <span class="built_in">this</span>.getLeftIndex(k)</span><br><span class="line">      <span class="comment">// 判断是否有右孩子，并且右孩子是否大于左孩子</span></span><br><span class="line">      <span class="keyword">if</span> (j + <span class="number">1</span> &lt; <span class="built_in">this</span>.size() &amp;&amp; <span class="built_in">this</span>.heap[j + <span class="number">1</span>] &gt; <span class="built_in">this</span>.heap[j]) j++</span><br><span class="line">      <span class="comment">// 判断父节点是否已经比子节点都大</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.heap[k] &gt;= <span class="built_in">this</span>.heap[j]) <span class="keyword">break</span></span><br><span class="line">      <span class="built_in">this</span>._swap(k, j)</span><br><span class="line">      k = j</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_swap</span>(<span class="params">left, right</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> rightValue = <span class="built_in">this</span>.heap[right]</span><br><span class="line">    <span class="built_in">this</span>.heap[right] = <span class="built_in">this</span>.heap[left]</span><br><span class="line">    <span class="built_in">this</span>.heap[left] = rightValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2017/05/08/others/170508/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2017/05/08/others/170508/" class="post-title-link" itemprop="url">计算机基础-网络开发</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-05-08 00:00:00" itemprop="dateCreated datePublished" datetime="2017-05-08T00:00:00+08:00">2017-05-08</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 15:57:12" itemprop="dateModified" datetime="2020-11-18T15:57:12+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E5%85%B6%E5%AE%83/" itemprop="url" rel="index"><span itemprop="name">其它</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>9.7k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>9 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="面向报文"><a href="#面向报文" class="headerlink" title="面向报文"></a>面向报文</h3><p>UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 UDP 只是报文的搬运工，不会对报文进行任何拆分和拼接操作。</p><p>具体来说：</p><ul><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul><h3 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h3><ul><li>UDP 是无连接的，也就是说通信不需要建立和断开连接。</li><li>UDP 也是不可靠的。协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的</li><li>UDP 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</li></ul><h3 id="高效性"><a href="#高效性" class="headerlink" title="高效性"></a>高效性</h3><p>因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达。所以 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。</p><p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-43739.png" alt="UDP Header"></p><p>头部包含了以下几个数据：</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li></ul><h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h3><p>TCP 头部比 UDP 头部复杂的多</p><p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043741.png" alt="TCP Header"></p><p>对于 TCP 头部来说，以下几个字段是很重要的：</p><ul><li><code>Sequence Number</code>，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文</li><li><code>Acknowledgement Number</code>，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到</li><li><code>Window Size</code>，窗口大小，表示还能接收多少字节的数据，用于流量控制</li><li>标识符<ul><li><code>URG=1</code>：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。</li><li><code>ACK=1</code>：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。</li><li><code>PSH=1</code>：该字段为一表示接收端应该立即将数据 <code>push</code> 给应用层，而不是等到缓冲区满后再提交。</li><li><code>RST=1</code>：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。</li><li><code>SYN=1</code>：当 <code>SYN=1</code>，<code>ACK=0</code> 时，表示当前报文段是一个连接请求报文。当 <code>SYN=1</code>，<code>ACK=1</code> 时，表示当前报文段是一个同意建立连接的应答报文。</li><li><code>FIN=1</code>：该字段为一表示此报文段是一个释放连接的请求报文。</li></ul></li></ul><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>HTTP 是无连接的，所以作为下层的 TCP 协议也是无连接的，虽然看似 TCP 将两端连接了起来，但是其实只是两端共同维护了一个状态</p><p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043743.png" alt="TCP状态机"></p><p>TCP 的状态机是很复杂的，并且与建立断开连接时的握手息息相关，接下来就来详细描述下两种握手。</p><p>在这之前需要了解一个重要的性能指标 RTT。该指标表示发送端发送数据到接收到对端数据所需的往返时间。</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043744.png" alt="TCP握手"></p><p>在 TCP 协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 也是一个全双工的协议。</p><p>起初，两端都为 <code>CLOSED</code> 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后遍进入 <code>LISTEN</code> 状态，此时开始等待客户端发送数据。</p><p><strong>第一次握手</strong></p><p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 <code>SYN-SENT</code> 状态，<code>x</code> 表示客户端的数据通信初始序号。</p><p><strong>第二次握手</strong></p><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 <code>SYN-RECEIVED</code> 状态。</p><p><strong>第三次握手</strong></p><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入<code>ESTABLISHED</code> 状态，服务端收到这个应答后也进入 <code>ESTABLISHED</code> ˝，此时连接建立成功。</p><blockquote><p>第三次握手可以包含数据，通过 TCP 快速打开 TFO 技术。其实只要涉及到握手的协议，都可以使用类似 TFO 的方式，客户端和服务端存储相同 <code>cookie</code>，下次握手时发出 <code>cookie</code> 达到减少 RTT 的目的。</p></blockquote><p><strong>你是否有疑惑明明两次握手就可以建立起连接，为什么还需要第三次应答？</strong></p><p>因为这是为了防止失效的连接请求报文段被服务端接收，从而产生错误。可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 <code>ESTABLISHED</code> 状态。此时客户端其实是 <code>CLOSED</code> 状态，那么就会导致服务端一直等待，造成资源的浪费。</p><blockquote><p>在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 <code>SYN FLOOD</code> 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。</p></blockquote><h4 id="四次松手"><a href="#四次松手" class="headerlink" title="四次松手"></a>四次松手</h4><p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。</p><p><strong>第一次松手</strong></p><p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</p><p><strong>第二次松手</strong></p><p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 <code>CLOSE_WAIT</code> 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP 连接时双向的，所以 B 仍旧可以发送数据给 A。</p><p><strong>第三次松手</strong></p><p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 <code>LAST-ACK</code> 状态。</p><blockquote><p>通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。</p></blockquote><p><strong>第四次松手</strong></p><p>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 <code>TIME-WAIT</code> 状态。该状态会持续 <code>2MSL</code>（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 <code>CLOSED</code> 状态。当 B 收到确认应答后，也便进入 <code>CLOSED</code> 状态。</p><p><strong>为什么 A 要进入 <code>TIME-WAIT</code> 状态，等待 2MSL 时间后才进入 <code>CLOSED</code> 状态？</strong></p><p>为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 <code>CLOSED</code> 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。</p><h3 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h3><p>ARQ 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含停止等待 ARQ 和连续 ARQ</p><h4 id="停止等待-ARQ"><a href="#停止等待-ARQ" class="headerlink" title="停止等待 ARQ"></a>停止等待 ARQ</h4><p><strong>正常传输过程</strong></p><p>只要 A 向 B 发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。</p><p><strong>报文丢失或出错</strong></p><p>在报文传输的过程中可能会出现丢包。这时候超过定时器设定的时间就会再次发送丢包的数据直到对端响应，所以需要每次都备份发送的数据。</p><p>即使报文正常的传输到对端，也可能出现在传输过程中报文出错的问题。这时候对端会抛弃该报文并等待 A 端重传。</p><blockquote><p>一般定时器设定的时间都会大于一个 RTT 的平均时间。</p></blockquote><p><strong>ACK 超时或丢失</strong></p><p>对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 A 端照样会重传报文。这时候 B 端收到相同序号的报文会丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。</p><p>在超时的情况下也可能出现应答很迟到达，这时 A 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。</p><blockquote><p>这个协议的缺点就是传输效率低，在良好的网络环境下每次发送报文都得等待对端的 ACK 。</p></blockquote><h3 id="连续-ARQ"><a href="#连续-ARQ" class="headerlink" title="连续 ARQ"></a>连续 ARQ</h3><p>在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率。</p><p><strong>累计确认</strong><br>连续 ARQ 中，接收端会持续不断收到报文。如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号 + 1 的数据。</p><p>但是累计确认也有一个弊端。在连续接收报文时，可能会遇到接收到序号 <code>5</code> 的报文后，并未接到序号 <code>6</code> 的报文，然而序号 <code>7</code> 以后的报文已经接收。遇到这种情况时，ACK 只能回复 <code>6</code>，这样会造成发送端重复发送数据，这种情况下可以通过 Sack 来解决，这个会在下文说到。</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>在上面小节中讲到了发送窗口。在 TCP 中，两端都维护着窗口：分别为发送端窗口和接收端窗口。</p><p>发送端窗口包含已发送但未收到应答的数据和可以发送但是未发送的数据。</p><p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043747.png" alt="窗口滑动前"></p><p>发送端窗口是由接收窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。</p><p>当发送端接收到应答报文后，会随之将窗口进行滑动</p><p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043748.png" alt="窗口滑动后"></p><p>滑动窗口实现了流量控制。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据。</p><h4 id="Zero-窗口"><a href="#Zero-窗口" class="headerlink" title="Zero 窗口"></a>Zero 窗口</h4><p>在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动 <code>persistent timer</code> 。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接。</p><h3 id="拥塞处理"><a href="#拥塞处理" class="headerlink" title="拥塞处理"></a>拥塞处理</h3><p>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p><p>拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。</p><h4 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h4><p>慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。</p><p>慢开始算法步骤具体如下：</p><ol><li>连接初始设置拥塞窗口（Congestion Window） 为 <code>1MSS</code>（一个分段的最大数据量）</li><li>每过一个 RTT 就将窗口大小乘二</li><li>指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。</li></ol><h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加 <code>1</code>，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。</p><p>在传输过程中可能出现定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤：</p><ol><li>将阈值设为当前拥塞窗口的一半</li><li>将拥塞窗口设为 <code>1MSS</code></li><li>启动拥塞避免算法</li></ol><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号（没有 Sack 的情况下）。如果收到三个重复的 ACK，无需等待定时器超时再重发而是启动快速重传。具体算法分为两种：</p><p><strong>TCP Taho</strong> 实现如下：</p><ul><li>将阈值设为当前拥塞窗口的一半</li><li>将拥塞窗口设为 <code>1MSS</code></li><li>重新开始慢开始算法</li></ul><p><strong>TCP Reno</strong> 实现如下：</p><ul><li>拥塞窗口减半</li><li>将阈值设为当前拥塞窗口</li><li>进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段）</li><li>使用拥塞避免算法</li></ul><p><strong>TCP New Ren</strong> 改进<br><strong>TCP New Reno</strong> 算法改进了之前 <strong>TCP Reno</strong> 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。</p><p>在 <strong>TCP New Reno</strong> 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。</p><p>假如我有一个分段数据是 <code>1 ~ 10</code> 这十个序号的报文，其中丢失了序号为 <code>3</code> 和 <code>7</code> 的报文，那么该分段的最大序号就是 <code>10</code>。发送端只会收到 ACK 序号为 <code>3</code> 的应答。这时候重发序号为 <code>3</code> 的报文，接收方顺利接收并会发送 ACK 序号为 <code>7</code> 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 <code>7</code> 的报文，接收方顺利接收并会发送 ACK 序号为 <code>11</code> 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP 协议是个无状态协议，不会保存状态。</p><h3 id="Get-Post"><a href="#Get-Post" class="headerlink" title="Get/Post"></a>Get/Post</h3><p>先引入副作用和幂等的概念，副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。</p><p>幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 <code>10</code> 个和 <code>11</code> 个帐号是不幂等的，对文章进行更改 <code>10</code> 次和 <code>11</code> 次是幂等的。</p><p>在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。</p><p>在技术上说：</p><ul><li>Get 请求能缓存，Post 不能</li><li>Post 相对 Get 安全一点点，因为 Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。</li><li>Post 可以通过 <code>request body</code> 来传输比 Get 更多的数据</li><li>URL 有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的</li><li>Post 支持更多的编码类型且不对数据类型限制</li></ul><h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><h4 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h4><ul><li><code>200 OK</code>，表示从客户端发来的请求在服务器端被正确处理</li><li><code>204 No content</code>，表示请求成功，但响应报文不含实体的主体部分</li><li><code>205 Reset Content</code>，表示请求成功，但响应报文不含实体的主体部分，但是与 <code>204</code> 响应不同在于要求请求方重置内容</li><li>206 Partial Content`，进行范围请求</li></ul><h4 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h4><ul><li><code>301 moved permanently</code>，永久性重定向，表示资源已被分配了新的 URL</li><li><code>302 found</code>，临时性重定向，表示资源临时被分配了新的 URL</li><li><code>303 see other</code>，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li><li><code>304 not modified</code>，表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li><code>307 temporary redirect</code>，临时重定向，和 <code>302</code> 含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li></ul><h4 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h4><ul><li><code>400 bad request</code>，请求报文存在语法错误</li><li><code>401 unauthorized</code>，表示发送的请求需要有通过 HTTP 认证的认证信息</li><li><code>403 forbidden</code>，表示对请求资源的访问被服务器拒绝</li><li><code>404 not found</code>，表示在服务器上没有找到请求的资源</li></ul><h4 id="5XX-服务端错误"><a href="#5XX-服务端错误" class="headerlink" title="5XX 服务端错误"></a>5XX 服务端错误</h4><ul><li><code>500 internal sever error</code>，表示服务器端在执行请求时发生了错误</li><li><code>501 Not Implemented</code>，表示服务器不支持当前请求所需要的某个功能</li><li><code>503 service unavailable</code>，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li></ul><h3 id="HTTP-字段"><a href="#HTTP-字段" class="headerlink" title="HTTP 字段"></a>HTTP 字段</h3><table><thead><tr><th align="left">通用字段</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Cache-Control</td><td align="left">控制缓存的行为</td></tr><tr><td align="left">Connection</td><td align="left">浏览器想要优先使用的连接类型，比如 keep-alive</td></tr><tr><td align="left">Date</td><td align="left">创建报文时间</td></tr><tr><td align="left">Pragma</td><td align="left">报文指令</td></tr><tr><td align="left">Transfer-Encoding</td><td align="left">传输编码方式</td></tr><tr><td align="left">Upgrade</td><td align="left">要求客户端升级协议</td></tr><tr><td align="left">Via</td><td align="left">代理服务器相关信息</td></tr><tr><td align="left">Warning</td><td align="left">在内容中可能存在错误</td></tr></tbody></table><table><thead><tr><th align="left">请求字段</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Accept</td><td align="left">能正确接收的媒体类型</td></tr><tr><td align="left">Accept-Charset</td><td align="left">能正确接收的字符集</td></tr><tr><td align="left">Accept-Encoding</td><td align="left">能正确接收的编码格式列表</td></tr><tr><td align="left">Accept-Language</td><td align="left">能正确接收的语言列表</td></tr><tr><td align="left">Expect</td><td align="left">期待服务端的指定行为</td></tr><tr><td align="left">From</td><td align="left">请求方邮箱地址</td></tr><tr><td align="left">Host</td><td align="left">服务器的域名</td></tr><tr><td align="left">If-Match</td><td align="left">两端资源标记比较</td></tr><tr><td align="left">If-Modified-Since</td><td align="left">本地资源未修改返回 304（比较时间）</td></tr><tr><td align="left">If-None-Match</td><td align="left">本地资源未修改返回 304（比较标记）</td></tr><tr><td align="left">Max-Forwards</td><td align="left">限制可被代理及网关转发的次数</td></tr><tr><td align="left">Proxy-Authorization</td><td align="left">向代理服务器发送验证信息</td></tr><tr><td align="left">Range</td><td align="left">请求某个内容的一部分</td></tr><tr><td align="left">Referer</td><td align="left">表示浏览器所访问的前一个页面</td></tr><tr><td align="left">TE</td><td align="left">传输编码方式</td></tr><tr><td align="left">User-Agent</td><td align="left">客户端信息</td></tr></tbody></table><table><thead><tr><th align="left">响应字段</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Accept-Ranges</td><td align="left">是否支持某些种类的范围</td></tr><tr><td align="left">Age</td><td align="left">资源在代理缓存中存在的时间</td></tr><tr><td align="left">ETag</td><td align="left">资源标识</td></tr><tr><td align="left">Location</td><td align="left">客户端重定向到某个 URL</td></tr><tr><td align="left">Proxy-Authenticate</td><td align="left">向代理服务器发送验证信息</td></tr><tr><td align="left">Server</td><td align="left">服务器名字</td></tr><tr><td align="left">WWW-Authenticate</td><td align="left">获取资源需要的验证信息</td></tr></tbody></table><table><thead><tr><th align="left">实体字段</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Allow 资源的正确请求方式</td><td align="left"></td></tr><tr><td align="left">Content-Encoding</td><td align="left">内容的编码格式</td></tr><tr><td align="left">Content-Language</td><td align="left">内容使用的语言</td></tr><tr><td align="left">Content-Length request body</td><td align="left">长度</td></tr><tr><td align="left">Content-Location</td><td align="left">返回数据的备用地址</td></tr><tr><td align="left">Content-MD5 Base64</td><td align="left">加密格式的内容 MD5 检验值</td></tr><tr><td align="left">Content-Range</td><td align="left">内容的位置范围</td></tr><tr><td align="left">Content-Type</td><td align="left">内容的媒体类型</td></tr><tr><td align="left">Expires</td><td align="left">内容的过期时间</td></tr><tr><td align="left">Last_modified</td><td align="left">内容的最后修改时间</td></tr></tbody></table><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。</p><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><p>TLS 协议位于传输层之上，应用层之下。首次进行 TLS 协议传输需要两个 RTT ，接下来可以通过 <code>Session Resumption</code> 减少到一个 RTT。</p><p>在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。</p><h4 id="对称加密："><a href="#对称加密：" class="headerlink" title="对称加密："></a>对称加密：</h4><p>对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。</p><h4 id="非对称加密："><a href="#非对称加密：" class="headerlink" title="非对称加密："></a>非对称加密：</h4><p>有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</p><p>TLS 握手过程如下图：</p><p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043749.jpg" alt="TLS握手"></p><ol><li>客户端发送一个随机值，需要的协议和加密方式</li><li>服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）</li><li>客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li><li>服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密</li></ol><p>通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。</p><blockquote><p>以上说明的都是 TLS 1.2 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了。</p></blockquote><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><p>HTTP 2.0 相比于 HTTP 1.X，可以说是大幅度提高了 web 的性能。</p><p>在 HTTP 1.X 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量，当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p><h3 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h3><p>HTTP 2.0 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP 2.0 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>在 HTTP 2.0 中，有两个非常重要的概念，分别是帧 <code>frame</code> 和流 <code>stream</code>。</p><p>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</p><p>多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p><h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>在 HTTP 1.X 中，我们使用文本的形式传输 <code>header</code>，在 <code>header</code> 携带 <code>cookie</code> 的情况下，可能每次都需要重复传输几百到几千的字节。</p><p>在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 <code>header</code> 进行编码，减少了 <code>header</code> 的大小。并在两端维护了索引表，用于记录出现过的 <code>header</code> ，后面在传输过程中就可以传输已经记录过的 <code>header</code> 的键名，对端收到数据后就可以通过键名找到对应的值。</p><h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。</p><p>可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 <code>push</code> 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 <code>prefetch</code> 。</p><h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>这是一个谷歌出品的基于 UDP 实现的同为传输层的协议，目标是希望替代 TCP 协议：</p><ul><li>该协议支持多路复用，虽然 HTTP 2.0 也支持多路复用，但是下层仍是 TCP，因为 TCP 的重传机制，只要一个包丢失就得判断丢失包并且重传，导致发生队头阻塞的问题，但是 UDP 没有这个机制</li><li>实现了自己的加密协议，通过类似 TCP 的 TFO 机制可以实现 <code>0-RTT</code>，当然 TLS 1.3 已经实现了 <code>0-RTT</code> 了</li><li>支持重传和纠错机制（向前恢复），在只丢失一个包的情况下不需要重传，使用纠错机制恢复丢失的包<ul><li>纠错机制：通过异或的方式，算出发出去的数据的异或值并单独发出一个包，服务端在发现有一个包丢失的情况下，通过其他数据包和异或值包算出丢失包</li><li>在丢失两个包或以上的情况就使用重传机制，因为算不出来了</li></ul></li></ul><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS 的作用就是通过域名查询到具体的 IP。</p><p>因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。</p><p>在 TCP 握手之前就已经进行了 DNS 查询，这个查询是操作系统自己做的。当你在浏览器中想访问 <code>www.google.com</code> 时，会进行一下操作：</p><ol><li>操作系统首先会在本地缓存中查询</li><li>若本地没有会去系统配置的 DNS 服务器中查询</li><li>若 DNS 服务器没有会直接去 DNS 根服务器查询，这一步会找出负责 <code>com</code> 这个一级域名的服务器</li><li>然后去该服务器查询 <code>google</code> 这个二级域名</li><li>最后查询的三级域名是我们自己配置的，你可以给 <code>www</code> 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP</li></ol><p>以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。</p><blockquote><p>DNS 是基于 UDP 做的查询。</p></blockquote><h2 id="页面加载过程"><a href="#页面加载过程" class="headerlink" title="页面加载过程"></a>页面加载过程</h2><p>这是一个很经典的面试题，在这题中可以将本文讲得内容都串联起来：</p><ol><li>首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来；</li><li>然后是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器，接着包会再被封装到数据链路层的数据帧结构中，最后就是物理层面传输；</li><li>TCP 握手结束后会进行 TLS 握手，然后就开始正式传输数据；</li><li>数据在进入服务端之前，可能还会先经过负载均衡服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件；</li><li>首先浏览器会判断状态码是什么，如果是 <code>200</code> 那就继续解析，如果 <code>400</code> 或 <code>500</code> 的话就会报错，如果 <code>300</code> 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错；</li><li>浏览器开始解析文件，如果是 <code>gzip</code> 格式的话会先解压一下，然后根据文件的编码格式去解码文件；</li><li>文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 <code>script</code> 标签的话，会判断是否存在 <code>async</code> 或者 <code>defer</code> ，前者会并行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率;</li><li>初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件;</li><li>CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步确定页面元素的布局、样式等诸多方面内容;</li><li>在生成 Render 树的过程中，浏览器开始调用 GPU 绘制合成图层，将内容展示出来；</li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2017/04/15/others/170415/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2017/04/15/others/170415/" class="post-title-link" itemprop="url">正则表达式</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-04-15 00:00:00" itemprop="dateCreated datePublished" datetime="2017-04-15T00:00:00+08:00">2017-04-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 15:57:12" itemprop="dateModified" datetime="2020-11-18T15:57:12+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E5%85%B6%E5%AE%83/" itemprop="url" rel="index"><span itemprop="name">其它</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>4.5k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>4 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table><thead><tr><th align="center">元字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">.</td><td align="center">匹配任意字符除了换行符和回车符</td></tr><tr><td align="center">^</td><td align="center">匹配字符开始</td></tr><tr><td align="center">$</td><td align="center">匹配字符结束</td></tr><tr><td align="center">\</td><td align="center">转义字符</td></tr><tr><td align="center">\w</td><td align="center">匹配字母、数字或下划线</td></tr><tr><td align="center">\W</td><td align="center">匹配非字母、数字或下划线</td></tr><tr><td align="center">\d</td><td align="center">匹配数字</td></tr><tr><td align="center">\D</td><td align="center">匹配非数字</td></tr><tr><td align="center">\s</td><td align="center">匹配任意空白符</td></tr><tr><td align="center">\S</td><td align="center">匹配非空白符</td></tr><tr><td align="center">\b</td><td align="center">匹配字符开始或结束</td></tr><tr><td align="center">\B</td><td align="center">匹配字符非开始或结束</td></tr></tbody></table><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><table><thead><tr><th align="center">限定符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">*</td><td align="center">匹配字符重复 0 次或多次</td></tr><tr><td align="center">+</td><td align="center">匹配字符重复 1 次或多次</td></tr><tr><td align="center">?</td><td align="center">匹配字符重复 0 次或 1 次</td></tr><tr><td align="center">{n}</td><td align="center">匹配字符重复 n 次</td></tr><tr><td align="center">{n,}</td><td align="center">匹配字符重复 n 次或多次</td></tr><tr><td align="center">{n,m}</td><td align="center">匹配字符重复 n 次到 m 次</td></tr><tr><td align="center">(abc)</td><td align="center">匹配小括号内相同字符串</td></tr><tr><td align="center">[abc]</td><td align="center">匹配中括号内任意字符</td></tr><tr><td align="center">[^abc]/！</td><td align="center">匹配除了中括号内任意字符</td></tr><tr><td align="center">|</td><td align="center">匹配 | 前后任意字符</td></tr></tbody></table><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><table><thead><tr><th align="center">修饰符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">i</td><td align="center">忽略大小写</td></tr><tr><td align="center">g</td><td align="center">全局匹配</td></tr><tr><td align="center">m</td><td align="center">多行匹配</td></tr></tbody></table><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><table><thead><tr><th align="center">修饰符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">$1/$2</td><td align="center">引用匹配字符</td></tr><tr><td align="center">abc(?=regex)</td><td align="center">正前向查找获得 abc 开头的匹配字符</td></tr><tr><td align="center">abc(?!regex)</td><td align="center">反前向查找过滤 abc 开头的匹配字符</td></tr><tr><td align="center">(?&lt;=regex)abc</td><td align="center">正后向查找获得 abc 结尾的匹配字符</td></tr><tr><td align="center">(?&lt;!regex)abc</td><td align="center">反后向查找获得 abc 结尾的匹配字符</td></tr></tbody></table><h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><h3 id="数字校验"><a href="#数字校验" class="headerlink" title="数字校验"></a>数字校验</h3><ol><li>数字：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[0-9]\*\$</span><br></pre></td></tr></table></figure><ol start="2"><li>n 位的数字：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;n&#125;\$</span><br></pre></td></tr></table></figure><ol start="3"><li>至少 n 位的数字：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;n,&#125;\$</span><br></pre></td></tr></table></figure><ol start="4"><li>m-n 位的数字：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;m,n&#125;\$</span><br></pre></td></tr></table></figure><ol start="5"><li>零和非零开头的数字：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(0|[1-9][0-9]\*)\$</span><br></pre></td></tr></table></figure><ol start="6"><li>非零开头的最多带两位小数的数字：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^([1-9][0-9]\*)+(.[0-9]&#123;1,2&#125;)?\$</span><br></pre></td></tr></table></figure><ol start="7"><li>带 1-2 位小数的正数或负数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(\-)?\d+(\.\d&#123;1,2&#125;)?\$</span><br></pre></td></tr></table></figure><ol start="8"><li>正数、负数、和小数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(\-|\+)?\d+(\.\d+)?\$</span><br></pre></td></tr></table></figure><ol start="9"><li>有两位小数的正实数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[0-9]+(.[0-9]&#123;2&#125;)?\$</span><br></pre></td></tr></table></figure><ol start="10"><li>有 1~3 位小数的正实数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[0-9]+(.[0-9]&#123;1,3&#125;)?\$</span><br></pre></td></tr></table></figure><ol start="11"><li>非零的正整数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[1-9]\d*\$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$</span><br></pre></td></tr></table></figure><ol start="12"><li>非零的负整数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\-[1-9][]0-9&quot;_\$ 或 ^-[1-9]\d_\$</span><br></pre></td></tr></table></figure><ol start="13"><li>非负整数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d+$ 或 ^[1-9]\d*|0$</span><br></pre></td></tr></table></figure><ol start="14"><li>非正整数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^-[1-9]\d\*|0$ 或 ^((-\d+)|(0+))$</span><br></pre></td></tr></table></figure><ol start="15"><li>非负浮点数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</span><br></pre></td></tr></table></figure><ol start="16"><li>非正浮点数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</span><br></pre></td></tr></table></figure><ol start="17"><li>正浮点数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</span><br></pre></td></tr></table></figure><ol start="18"><li>负浮点数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</span><br></pre></td></tr></table></figure><ol start="19"><li>浮点数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</span><br></pre></td></tr></table></figure><h3 id="字符校验"><a href="#字符校验" class="headerlink" title="字符校验"></a>字符校验</h3><ol><li>汉字：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[\u4e00-\u9fa5]&#123;0,&#125;\$</span><br></pre></td></tr></table></figure><ol start="2"><li>英文和数字：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$</span><br></pre></td></tr></table></figure><ol start="3"><li>长度为 3-20 的所有字符：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^.&#123;3,20&#125;\$</span><br></pre></td></tr></table></figure><ol start="4"><li>由 26 个英文字母组成的字符串：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[A-Za-z]+\$</span><br></pre></td></tr></table></figure><ol start="5"><li>由 26 个大写英文字母组成的字符串：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[A-Z]+\$</span><br></pre></td></tr></table></figure><ol start="6"><li>由 26 个小写英文字母组成的字符串：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[a-z]+\$</span><br></pre></td></tr></table></figure><ol start="7"><li>由数字和 26 个英文字母组成的字符串：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[A-Za-z0-9]+\$</span><br></pre></td></tr></table></figure><ol start="8"><li>由数字、26 个英文字母或者下划线组成的字符串：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\w+$ 或 ^\w&#123;3,20&#125;$</span><br></pre></td></tr></table></figure><ol start="9"><li>中文、英文、数字包括下划线：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[\u4E00-\u9FA5A-Za-z0-9_]+\$</span><br></pre></td></tr></table></figure><ol start="10"><li>中文、英文、数字但不包括下划线等符号：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$</span><br></pre></td></tr></table></figure><ol start="11"><li>可以输入含有^%&amp;’,;=?$&quot;等字符：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^%&amp;&#39;,;&#x3D;?$\x22]+</span><br></pre></td></tr></table></figure><ol start="12"><li>禁止输入含有~的字符：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^~\x22]+</span><br></pre></td></tr></table></figure><h3 id="特殊校验"><a href="#特殊校验" class="headerlink" title="特殊校验"></a>特殊校验</h3><ol><li>Email 地址：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\w+([-+.]\w+)_@\w+([-.]\w+)_\.\w+([-.]\w+)\*\$</span><br></pre></td></tr></table></figure><ol start="2"><li>域名：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a-zA-Z0-9][-a-za-z0-9]&#123;0,62&#125;(&#x2F;.[a-zA-Z0-9][-a-za-z0-9]&#123;0,62&#125;)+&#x2F;.?</span><br></pre></td></tr></table></figure><ol start="3"><li>网址：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a-zA-z]+:&#x2F;&#x2F;[^\s]_ 或 ^http:&#x2F;&#x2F;([\w-]+\.)+[\w-]+(&#x2F;[\w-.&#x2F;?%&amp;&#x3D;]_)?\$</span><br></pre></td></tr></table></figure><ol start="4"><li>手机号码（可根据目前国内收集号扩展前两位开头号码）：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;\$</span><br></pre></td></tr></table></figure><ol start="5"><li>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;\$</span><br></pre></td></tr></table></figure><ol start="6"><li>国内电话号码(0511-4405222、021-87888822)：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>15 位身份证号：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[1-9]\d&#123;5&#125;\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;2&#125;\$</span><br></pre></td></tr></table></figure><ol start="8"><li>18 位身份证号：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]\$</span><br></pre></td></tr></table></figure><ol start="9"><li>帐号是否合法(字母开头，允许 5-16 字节，允许字母数字下划线)：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[a-zA-Z][a-za-z0-9_]&#123;4,15&#125;\$</span><br></pre></td></tr></table></figure><ol start="10"><li>密码(以字母开头，长度在 6~18 之间，只能包含字母、数字和下划线)：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[a-zA-Z]\w&#123;5,17&#125;\$</span><br></pre></td></tr></table></figure><ol start="11"><li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(?&#x3D;._\d)(?&#x3D;._[a-z])(?&#x3D;.\*[A-Z]).&#123;8,10&#125;\$</span><br></pre></td></tr></table></figure><ol start="12"><li>日期格式：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</span><br></pre></td></tr></table></figure><ol start="13"><li>一年的 12 个月(01 ～ 09 和 1 ～ 12)：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(0?[1-9]|1[0-2])\$</span><br></pre></td></tr></table></figure><ol start="14"><li>一个月的 31 天(01 ～ 09 和 1 ～ 31)：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^((0?[1-9])|((1|2)[0-9])|30|31)\$</span><br></pre></td></tr></table></figure><ol start="15"><li><p>钱的输入格式：</p><ul><li>有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[1-9][0-9]\*\$</span><br></pre></td></tr></table></figure><ul><li>这表示任意一个不以 0 开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(0|[1-9][0-9]\*)\$</span><br></pre></td></tr></table></figure><ul><li>一个 0 或者一个不以 0 开头的数字.我们还可以允许开头有一个负号：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(0|-?[1-9][0-9]\*)\$</span><br></pre></td></tr></table></figure><ul><li>这表示一个 0 或者一个可能为负的开头不为 0 的数字.让用户以 0 开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[0-9]+(.[0-9]+)?\$</span><br></pre></td></tr></table></figure><ul><li>必须说明的是,小数点后面至少应该有 1 位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[0-9]+(.[0-9]&#123;2&#125;)?\$</span><br></pre></td></tr></table></figure><ul><li>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[0-9]+(.[0-9]&#123;1,2&#125;)?\$</span><br></pre></td></tr></table></figure><ul><li>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)\*(.[0-9]&#123;1,2&#125;)?\$</span><br></pre></td></tr></table></figure><ul><li>1 到 3 个数字,后面跟着任意个 逗号+3 个数字,逗号成为可选,而不是必须：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)\*)(.[0-9]&#123;1,2&#125;)?\$</span><br></pre></td></tr></table></figure><blockquote><p>别忘了”+”可以用”*“替代如果你觉得空字符串也可以接受的话，别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里。</p></blockquote></li><li><p>xml 文件：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|m][l|L]\$</span><br></pre></td></tr></table></figure><ol start="17"><li>中文字符的正则表达式：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[\u4e00-\u9fa5]</span><br></pre></td></tr></table></figure><ol start="18"><li>双字节字符：(&lt;包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计 2，ASCII 字符计 1)&gt;)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^\x00-\xff]</span><br></pre></td></tr></table></figure><ol start="19"><li>空白行的正则表达式： (可以用来删除空白行)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\n\s\*\r</span><br></pre></td></tr></table></figure><ol start="20"><li>HTML 标记的正则表达式：(对于复杂的嵌套标记无能为力)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;(\S*?)[^&gt;]*&gt;._?&lt;&#x2F;\1&gt;|&lt;._? &#x2F;&gt;</span><br></pre></td></tr></table></figure><ol start="21"><li>首尾空白字符的正则表达式： (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\s*|\s*$或(^\s*)|(\s*$)</span><br></pre></td></tr></table></figure><ol start="22"><li>腾讯 QQ 号： (腾讯 QQ 号从 10000 开始)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1-9][0-9]&#123;4,&#125;</span><br></pre></td></tr></table></figure><ol start="23"><li>中国邮政编码： (中国邮政编码为 6 位数字)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1-9]\d&#123;5&#125;(?!\d)</span><br></pre></td></tr></table></figure><ol start="24"><li>IP 地址： (提取 IP 地址时有用)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d+\.\d+\.\d+\.\d+</span><br></pre></td></tr></table></figure><ol start="25"><li>IP 地址：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2017/03/18/frontend/170318/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2017/03/18/frontend/170318/" class="post-title-link" itemprop="url">jQuery API源生实现</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-03-18 00:00:00" itemprop="dateCreated datePublished" datetime="2017-03-18T00:00:00+08:00">2017-03-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 15:57:04" itemprop="dateModified" datetime="2020-11-18T15:57:04+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>18k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>16 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>随着 React、Angular、Vue 等前端框架的流行，直接操作 DOM 的方式逐渐被抛弃，jQuery 的使用场景大大减少。这里总结了部分 jQuery API 对应的源生是实现方式，暂时只支持 IE10 以上浏览器。</p><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>常用的 <code>id</code>、<code>class</code>、属性 选择器都可以使用 <code>document.querySelector</code> 或 <code>document.querySelectorAll</code> 替代。区别是：</p><ul><li><code>document.querySelector</code> 返回第一个匹配的 Node</li><li><code>document.querySelectorAll</code> 返回所有匹配的 NodeList，通过 <code>[].slice.call()</code> 可以把它转成 Array</li><li>如果匹配不到任何 Node，jQuery 返回空数组 <code>[]</code>，但 <code>document.querySelector</code> 返回 <code>null</code>，注意空指针异常。当找不到时，也可以使用 <code>||</code> 设置默认的值，如 <code>document.querySelectorAll(selector) || []</code></li></ul><blockquote><p>注意：<code>document.querySelector</code> 和 <code>document.querySelectorAll</code> 性能很差。如果想提高性能，尽量使用 <code>document.getElementById</code>、<code>document.getElementsByClassName</code> 或 <code>document.getElementsByTagName</code>。</p></blockquote><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$(<span class="string">&#x27;selector&#x27;</span>)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;selector&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="ID-选择器"><a href="#ID-选择器" class="headerlink" title="ID 选择器"></a>ID 选择器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$(<span class="string">&#x27;#id&#x27;</span>)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;#id&#x27;</span>)</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;id&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$(<span class="string">&#x27;.class&#x27;</span>)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.class&#x27;</span>)</span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;class&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$(<span class="string">&#x27;a[target=_blank]&#x27;</span>)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;a[target=_blank]&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.find(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.querySelectorAll(<span class="string">&#x27;li&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器"></a>兄弟选择器</h3><ul><li>兄弟元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.siblings()</span><br><span class="line"><span class="comment">// Native - latest, Edge13+</span></span><br><span class="line">[...el.parentNode.children].filter(<span class="function"><span class="params">child</span> =&gt;</span> child !== el)</span><br><span class="line"><span class="comment">// Native (alternative) - latest, Edge13+</span></span><br><span class="line"><span class="built_in">Array</span>.from(el.parentNode.children).filter(<span class="function"><span class="params">child</span> =&gt;</span> child !== el)</span><br><span class="line"><span class="comment">// Native - IE10+</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.filter.call(el.parentNode.children, <span class="function"><span class="params">child</span> =&gt;</span> child !== el)</span><br></pre></td></tr></table></figure><ul><li>上一个元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.prev()</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.previousElementSibling</span><br></pre></td></tr></table></figure><ul><li>下一个元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next</span></span><br><span class="line">$el.next()</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.nextElementSibling</span><br></pre></td></tr></table></figure><h3 id="Closest"><a href="#Closest" class="headerlink" title="Closest"></a>Closest</h3><p>Closest 从当前元素开始沿 DOM 树向上搜索获得匹配选择器的第一个祖先元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.closest(queryString)</span><br><span class="line"><span class="comment">// Native - Only latest, NO IE</span></span><br><span class="line">el.closest(selector)</span><br><span class="line"><span class="comment">// Native - IE10+</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closest</span>(<span class="params">el, selector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> matchesSelector = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector</span><br><span class="line"></span><br><span class="line">  el = el.parentElement</span><br><span class="line">  <span class="keyword">while</span> (el) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matchesSelector.call(el, selector)) &#123;</span><br><span class="line">      <span class="keyword">return</span> el</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el = el.parentElement</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ParentsUntil"><a href="#ParentsUntil" class="headerlink" title="ParentsUntil"></a>ParentsUntil</h3><p>ParentsUntil 获取当前每一个匹配元素集的祖先，不包括匹配元素的本身：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.parentsUntil(selector, filter)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parentsUntil</span>(<span class="params">el, selector, filter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">const</span> matchesSelector = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector</span><br><span class="line"></span><br><span class="line">  el = el.parentElement</span><br><span class="line">  <span class="keyword">while</span> (el &amp;&amp; !matchesSelector.call(el, selector)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!filter || matchesSelector.call(el, filter)) &#123;</span><br><span class="line">      result.push(el)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el = el.parentElement</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h3><ul><li>Input/Textarea</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$(<span class="string">&#x27;#my-input&#x27;</span>).val()</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;#my-input&#x27;</span>).value</span><br></pre></td></tr></table></figure><ul><li>获取 <code>radio</code> 数组中 <code>e.currentTarget</code> 索引</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$(<span class="string">&#x27;.radio&#x27;</span>).index(e.currentTarget)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.indexOf.call(<span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.radio&#x27;</span>), e.currentTarget)</span><br></pre></td></tr></table></figure><h3 id="Iframe-Contents"><a href="#Iframe-Contents" class="headerlink" title="Iframe Contents"></a>Iframe Contents</h3><p>jQuery 对象的 <code>iframe contents()</code> 返回的是 <code>iframe</code> 内的 <code>document</code>：</p><ul><li>Iframe contents</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$iframe.contents()</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">iframe.contentDocument</span><br></pre></td></tr></table></figure><ul><li>Iframe Query</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$iframe.contents().find(<span class="string">&#x27;.css&#x27;</span>)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">iframe.contentDocument.querySelectorAll(<span class="string">&#x27;.css&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Attibute"><a href="#Attibute" class="headerlink" title="Attibute"></a>Attibute</h3><ul><li>获取属性：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.attr(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.getAttribute(<span class="string">&#x27;foo&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>设置属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery, note that this works in memory without change the DOM</span></span><br><span class="line">$el.attr(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.setAttribute(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>获取 <code>data-</code> 属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.data(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// Native (use `getAttribute`)</span></span><br><span class="line">el.getAttribute(<span class="string">&#x27;data-foo&#x27;</span>)</span><br><span class="line"><span class="comment">// Native (use `dataset` if only need to support IE 11+)</span></span><br><span class="line">el.dataset[<span class="string">&#x27;foo&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS-1"><a href="#CSS-1" class="headerlink" title="CSS"></a>CSS</h3><ul><li>Get style</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.css(<span class="string">&#x27;color&#x27;</span>)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="comment">// 注意：此处为了解决当 style 值为 auto 时，返回 auto 的问题</span></span><br><span class="line"><span class="keyword">const</span> win = el.ownerDocument.defaultView</span><br><span class="line"><span class="comment">// null 的意思是不返回伪类元素</span></span><br><span class="line">win.getComputedStyle(el, <span class="literal">null</span>).color</span><br></pre></td></tr></table></figure><ul><li>Set style</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.css(&#123; <span class="attr">color</span>: <span class="string">&#x27;#ff0011&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.style.color = <span class="string">&#x27;#ff0011&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>Get/Set Styles</li></ul><blockquote><p>注意，如果想一次设置多个 style，可以参考 <a target="_blank" rel="noopener" href="https://github.com/oneuijs/oui-dom-utils/blob/master/src/index.js#L194">oui-dom-utils</a> 中 setStyles 方法。</p></blockquote><ul><li>Add class</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.addClass(className)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.classList.add(className)</span><br></pre></td></tr></table></figure><ul><li>Remove class</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.removeClass(className)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.classList.remove(className)</span><br></pre></td></tr></table></figure><ul><li>Have class</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.hasClass(className)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.classList.contains(className)</span><br></pre></td></tr></table></figure><ul><li>Toggle class</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.toggleClass(className)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.classList.toggle(className)</span><br></pre></td></tr></table></figure><h3 id="Width-Height"><a href="#Width-Height" class="headerlink" title="Width/Height"></a>Width/Height</h3><p>Width 与 Height 获取方法相同，下面以 Height 为例：</p><ul><li>Window height</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// window height</span></span><br><span class="line">$(<span class="built_in">window</span>).height()</span><br><span class="line"><span class="comment">// 含 scrollbar</span></span><br><span class="line"><span class="built_in">window</span>.document.documentElement.clientHeight</span><br><span class="line"><span class="comment">// 不含 scrollbar，与 jQuery 行为一致</span></span><br><span class="line"><span class="built_in">window</span>.innerHeight</span><br></pre></td></tr></table></figure><ul><li>Document height</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$(<span class="built_in">document</span>).height()</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="keyword">const</span> body = <span class="built_in">document</span>.body</span><br><span class="line"><span class="keyword">const</span> html = <span class="built_in">document</span>.documentElement</span><br><span class="line"><span class="keyword">const</span> height = <span class="built_in">Math</span>.max(body.offsetHeight, body.scrollHeight, html.clientHeight, html.offsetHeight, html.scrollHeight)</span><br></pre></td></tr></table></figure><ul><li>Element height</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.height()</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHeight</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> styles = <span class="built_in">this</span>.getComputedStyle(el)</span><br><span class="line">  <span class="keyword">const</span> height = el.offsetHeight</span><br><span class="line">  <span class="keyword">const</span> borderTopWidth = <span class="built_in">parseFloat</span>(styles.borderTopWidth)</span><br><span class="line">  <span class="keyword">const</span> borderBottomWidth = <span class="built_in">parseFloat</span>(styles.borderBottomWidth)</span><br><span class="line">  <span class="keyword">const</span> paddingTop = <span class="built_in">parseFloat</span>(styles.paddingTop)</span><br><span class="line">  <span class="keyword">const</span> paddingBottom = <span class="built_in">parseFloat</span>(styles.paddingBottom)</span><br><span class="line">  <span class="keyword">return</span> height - borderBottomWidth - borderTopWidth - paddingTop - paddingBottom</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 精确到整数（border-box 时为 height - border 值，content-box 时为 height + padding 值）</span></span><br><span class="line">el.clientHeight</span><br><span class="line"><span class="comment">// 精确到小数（border-box 时为 height 值，content-box 时为 height + padding + border 值）</span></span><br><span class="line">el.getBoundingClientRect().height</span><br></pre></td></tr></table></figure><h3 id="Position-Offset"><a href="#Position-Offset" class="headerlink" title="Position/Offset"></a>Position/Offset</h3><ul><li>Position 获得匹配元素相对父元素的偏移</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.position();</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">&#123; <span class="attr">left</span>: el.offsetLeft, <span class="attr">top</span>: el.offsetTop &#125;</span><br></pre></td></tr></table></figure><ul><li>Offset 获得匹配元素相对文档的偏移</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.offset()</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOffset</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> box = el.getBoundingClientRect()</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    top: box.top + <span class="built_in">window</span>.pageYOffset - <span class="built_in">document</span>.documentElement.clientTop,</span><br><span class="line">    left: box.left + <span class="built_in">window</span>.pageXOffset - <span class="built_in">document</span>.documentElement.clientLeft</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Scroll-Top"><a href="#Scroll-Top" class="headerlink" title="Scroll Top"></a>Scroll Top</h3><p>获取元素滚动条垂直位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$(<span class="built_in">window</span>).scrollTop()</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">;(<span class="built_in">document</span>.documentElement &amp;&amp; <span class="built_in">document</span>.documentElement.scrollTop) || <span class="built_in">document</span>.body.scrollTop</span><br></pre></td></tr></table></figure><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><p>从 DOM 中移除元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.remove()</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.parentNode.removeChild(el)</span><br><span class="line"><span class="comment">// Native - Only latest, NO IE</span></span><br><span class="line">el.remove()</span><br></pre></td></tr></table></figure><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><ul><li>Get 返回指定元素及其后代的文本内容</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.text()</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.textContent</span><br></pre></td></tr></table></figure><ul><li>Set 设置元素的文本内容</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.text(string)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.textContent = string</span><br></pre></td></tr></table></figure><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ul><li>Get HTML</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.html()</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.innerHTML</span><br></pre></td></tr></table></figure><ul><li>Set HTML</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.html(htmlString)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.innerHTML = htmlString</span><br></pre></td></tr></table></figure><h3 id="Append"><a href="#Append" class="headerlink" title="Append"></a>Append</h3><p>插入到子节点的末尾：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.append(<span class="string">&quot;&lt;div id=&#x27;container&#x27;&gt;hello&lt;/div&gt;&quot;</span>)</span><br><span class="line"><span class="comment">// Native (Element)</span></span><br><span class="line">el.appendChild(newEl)</span><br><span class="line"><span class="comment">// Native (HTML string)</span></span><br><span class="line">el.insertAdjacentHTML(<span class="string">&#x27;beforeend&#x27;</span>, <span class="string">&#x27;&lt;div id=&quot;container&quot;&gt;Hello World&lt;/div&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Prepend"><a href="#Prepend" class="headerlink" title="Prepend"></a>Prepend</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.prepend(<span class="string">&quot;&lt;div id=&#x27;container&#x27;&gt;hello&lt;/div&gt;&quot;</span>)</span><br><span class="line"><span class="comment">// Native (Element)</span></span><br><span class="line">el.insertBefore(newEl, el.firstChild)</span><br><span class="line"><span class="comment">// Native (HTML string)</span></span><br><span class="line">el.insertAdjacentHTML(<span class="string">&#x27;afterbegin&#x27;</span>, <span class="string">&#x27;&lt;div id=&quot;container&quot;&gt;Hello World&lt;/div&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="InsertBefore"><a href="#InsertBefore" class="headerlink" title="InsertBefore"></a>InsertBefore</h3><p>在选中元素前插入新节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$newEl.insertBefore(queryString)</span><br><span class="line"><span class="comment">// Native (Element)</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.querySelector(selector)</span><br><span class="line"><span class="keyword">if</span> (el.parentNode) &#123;</span><br><span class="line">  el.parentNode.insertBefore(newEl, el)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Native (HTML string)</span></span><br><span class="line">el.insertAdjacentHTML(<span class="string">&#x27;beforebegin &#x27;</span>, <span class="string">&#x27;&lt;div id=&quot;container&quot;&gt;Hello World&lt;/div&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="InsertAfter"><a href="#InsertAfter" class="headerlink" title="InsertAfter"></a>InsertAfter</h3><p>在选中元素后插入新节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$newEl.insertAfter(queryString)</span><br><span class="line"><span class="comment">// Native (Element)</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.querySelector(selector)</span><br><span class="line"><span class="keyword">if</span> (el.parentNode) &#123;</span><br><span class="line">  el.parentNode.insertBefore(newEl, el.nextSibling)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Native (HTML string)</span></span><br><span class="line">el.insertAdjacentHTML(<span class="string">&#x27;afterend&#x27;</span>, <span class="string">&#x27;&lt;div id=&quot;container&quot;&gt;Hello World&lt;/div&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Is"><a href="#Is" class="headerlink" title="Is"></a>Is</h3><p>如果匹配给定的选择器，返回 <code>true</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.is(selector)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.matches(selector)</span><br></pre></td></tr></table></figure><h3 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h3><p>深拷贝被选元素（生成被选元素的副本，包含子节点、文本和属性）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jQuery</span></span><br><span class="line">$el.clone()</span><br><span class="line"><span class="comment">//Native</span></span><br><span class="line"><span class="comment">//深拷贝添加参数&#x27;true&#x27;</span></span><br><span class="line">el.cloneNode()</span><br></pre></td></tr></table></figure><h3 id="Empty"><a href="#Empty" class="headerlink" title="Empty"></a>Empty</h3><p>移除所有子节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jQuery</span></span><br><span class="line">$el.empty()</span><br><span class="line"><span class="comment">//Native</span></span><br><span class="line">el.innerHTML = <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Wrap"><a href="#Wrap" class="headerlink" title="Wrap"></a>Wrap</h3><p>把每个被选元素放置在指定的 HTML 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jQuery</span></span><br><span class="line">$(<span class="string">&#x27;.inner&#x27;</span>).wrap(<span class="string">&#x27;&lt;div class=&quot;wrapper&quot;&gt;&lt;/div&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">//Native</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">document</span>.querySelector(<span class="string">&#x27;.inner&#x27;</span>), <span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  wrapper.className = <span class="string">&#x27;wrapper&#x27;</span></span><br><span class="line">  el.parentNode.insertBefore(wrapper, el)</span><br><span class="line">  el.parentNode.removeChild(el)</span><br><span class="line">  wrapper.appendChild(el)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Unwrap"><a href="#Unwrap" class="headerlink" title="Unwrap"></a>Unwrap</h3><p>移除被选元素的父元素的 DOM 结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$(<span class="string">&#x27;.inner&#x27;</span>).unwrap()</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.inner&#x27;</span>), <span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> elParentNode = el.parentNode</span><br><span class="line">  <span class="keyword">if</span> (elParentNode !== <span class="built_in">document</span>.body) &#123;</span><br><span class="line">    elParentNode.parentNode.insertBefore(el, elParentNode)</span><br><span class="line">    elParentNode.parentNode.removeChild(elParentNode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="ReplaceWith"><a href="#ReplaceWith" class="headerlink" title="ReplaceWith"></a>ReplaceWith</h3><p>用指定的元素替换被选的元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jQuery</span></span><br><span class="line">$(<span class="string">&#x27;.inner&#x27;</span>).replaceWith(<span class="string">&#x27;&lt;div class=&quot;outer&quot;&gt;&lt;/div&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">//Native</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.inner&#x27;</span>), <span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> outer = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  outer.className = <span class="string">&#x27;outer&#x27;</span></span><br><span class="line">  el.parentNode.insertBefore(outer, el)</span><br><span class="line">  el.parentNode.removeChild(el)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="SimpleParse"><a href="#SimpleParse" class="headerlink" title="SimpleParse"></a>SimpleParse</h3><p>解析 HTML/SVG/XML 字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$(<span class="string">`&lt;ol&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;a&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;b&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ol&gt;</span></span><br><span class="line"><span class="string">&lt;ol&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;c&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;d&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ol&gt;`</span>)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">range = <span class="built_in">document</span>.createRange()</span><br><span class="line">parse = range.createContextualFragment.bind(range)</span><br><span class="line">parse(<span class="string">`&lt;ol&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;a&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;b&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ol&gt;</span></span><br><span class="line"><span class="string">&lt;ol&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;c&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;d&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ol&gt;`</span>)</span><br></pre></td></tr></table></figure><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>Fetch API 是用于替换 XMLHttpRequest 处理 <code>ajax</code> 的新标准，Chrome 和 Firefox 均支持，旧浏览器可以使用 <code>polyfills</code> 提供支持。</p><p>IE9+ 请使用 <code>github/fetch</code>，IE8+ 请使用 <code>fetch-ie8</code>，JSONP 请使用 <code>fetch-jsonp</code>。</p><p>从服务器读取数据并替换匹配元素的内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$(selector).load(url, completeCallback)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">fetch(url)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> data.text())</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(selector).innerHTML = data</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(completeCallback)</span><br></pre></td></tr></table></figure><h2 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h2><h3 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(eventHandler)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="comment">// 检测 DOMContentLoaded 是否已完成</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.readyState !== <span class="string">&#x27;loading&#x27;</span>) &#123;</span><br><span class="line">  eventHandler()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, eventHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="On"><a href="#On" class="headerlink" title="On"></a>On</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.on(eventName, eventHandler)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.addEventListener(eventName, eventHandler)</span><br></pre></td></tr></table></figure><h3 id="Off"><a href="#Off" class="headerlink" title="Off"></a>Off</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.off(eventName, eventHandler)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.removeEventListener(eventName, eventHandler)</span><br></pre></td></tr></table></figure><h3 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$(el).trigger(<span class="string">&#x27;custom-event&#x27;</span>, &#123; <span class="attr">key1</span>: <span class="string">&#x27;data&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.CustomEvent) &#123;</span><br><span class="line">  <span class="keyword">const</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">&#x27;custom-event&#x27;</span>, &#123; <span class="attr">detail</span>: &#123; <span class="attr">key1</span>: <span class="string">&#x27;data&#x27;</span> &#125; &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> event = <span class="built_in">document</span>.createEvent(<span class="string">&#x27;CustomEvent&#x27;</span>)</span><br><span class="line">  event.initCustomEvent(<span class="string">&#x27;custom-event&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>, &#123; <span class="attr">key1</span>: <span class="string">&#x27;data&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line">el.dispatchEvent(event)</span><br></pre></td></tr></table></figure><h2 id="Utilities"><a href="#Utilities" class="headerlink" title="Utilities"></a>Utilities</h2><p>大部分实用工具都能在 Native API 中找到. 其他高级功能可以选用专注于该领域的稳定性和性能都更好的库来代替，推荐 <code>lodash</code>。</p><h3 id="Common"><a href="#Common" class="headerlink" title="Common"></a>Common</h3><ul><li><code>isArray</code> 检测参数是不是数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.isArray(range)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(range)</span><br></pre></td></tr></table></figure><ul><li><code>isWindow</code> 检测参数是不是 <code>window</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.isWindow(obj)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWindow</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj !== <span class="literal">null</span> &amp;&amp; obj !== <span class="literal">undefined</span> &amp;&amp; obj === obj.window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>inArray</code> 在数组中搜索指定值并返回索引 (找不到则返回 <code>-1</code>)。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.inArray(item, array)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">array.indexOf(item) &gt; -<span class="number">1</span></span><br><span class="line"><span class="comment">// ES6-way</span></span><br><span class="line">array.includes(item)</span><br></pre></td></tr></table></figure><ul><li><code>isNumeric</code> 检测传入的参数是不是数字</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.isNumeric(item)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumeric</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(n)) &amp;&amp; <span class="built_in">isFinite</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>isFunction</code> 检测传入的参数是不是 JavaScript 函数对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.isFunction(item)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> type = <span class="built_in">Object</span>.prototype.toString(item)</span><br><span class="line">  <span class="keyword">return</span> type === <span class="string">&#x27;[object Function]&#x27;</span> || type === <span class="string">&#x27;[object GeneratorFunction]&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>isEmptyObject</code> 检测对象是否为空 (包括不可枚举属性)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.isEmptyObject(obj)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmptyObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(obj).length === <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>isPlainObject</code> 检测是不是扁平对象 (使用 <code>&#123;&#125;</code> 或 <code>new Object</code> 创建)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.isPlainObject(obj)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj.nodeType || (obj !== <span class="literal">null</span> &amp;&amp; obj !== <span class="literal">undefined</span> &amp;&amp; obj === obj.window)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (obj.constructor &amp;&amp; !<span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj.constructor.prototype, <span class="string">&#x27;isPrototypeOf&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>extend</code> 合并多个对象的内容到第一个对象，<code>object.assign</code> 是 ES6 API，也可以使用 <code>polyfill</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.extend(&#123;&#125;, defaultOpts, opts)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, defaultOpts, opts)</span><br></pre></td></tr></table></figure><ul><li><code>trim</code> 移除字符串头尾空白</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.trim(string)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">string.trim()</span><br></pre></td></tr></table></figure><ul><li><code>map</code> 将数组或对象转化为包含新内容的数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.map(array, <span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">array.map(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>each</code> 轮询函数，可用于平滑的轮询对象和数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.each(array, <span class="function">(<span class="params">index, value</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">array.forEach(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>grep</code> 找到数组中符合过滤函数的元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.grep(array, <span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">array.filter(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>type</code> 检测对象的 JavaScript [Class] 内部类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.type(obj)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reTypeOf = <span class="regexp">/(?:^\[object\s(.*?)\]$)/</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString</span><br><span class="line">    .call(item)</span><br><span class="line">    .replace(reTypeOf, <span class="string">&#x27;$1&#x27;</span>)</span><br><span class="line">    .toLowerCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>merge</code> 合并第二个数组内容到第一个数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.merge(array1, array2)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="comment">// 使用 concat，不能去除重复值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].concat(...args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ES6，同样不能去除重复值</span></span><br><span class="line">array1 = [...array1, ...array2]</span><br><span class="line"><span class="comment">// 使用 Set，可以去除重复值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([].concat(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>now</code> 返回当前时间的数字呈现</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.now()</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="built_in">Date</span>.now()</span><br></pre></td></tr></table></figure><ul><li><code>proxy</code> 传入函数并返回一个新函数，该函数绑定指定上下文</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.proxy(fn, context)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">fn.bind(context)</span><br></pre></td></tr></table></figure><ul><li><code>makeArray</code> 类数组对象转化为真正的 JavaScript 数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.makeArray(arrayLike)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike)</span><br><span class="line"><span class="comment">// ES6-way</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike)</span><br></pre></td></tr></table></figure><h3 id="Contain"><a href="#Contain" class="headerlink" title="Contain"></a>Contain</h3><p>检测 DOM 元素是不是其他元素的后代：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.contains(el, child)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el !== child &amp;&amp; el.contains(child)</span><br></pre></td></tr></table></figure><h3 id="Globaleval"><a href="#Globaleval" class="headerlink" title="Globaleval"></a>Globaleval</h3><p>全局执行 JavaScript 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.globaleval(code)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Globaleval</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">  script.text = code</span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(script).parentNode.removeChild(script)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Use eval, but context of eval is current, context of $.Globaleval is global.</span></span><br><span class="line"><span class="built_in">eval</span>(code)</span><br></pre></td></tr></table></figure><h3 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h3><ul><li><code>parseHTML</code> 解析字符串为 DOM 节点数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.parseHTML(htmlString)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseHTML</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> context = <span class="built_in">document</span>.implementation.createHTMLDocument()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the base href for the created document so any parsed elements with URLs</span></span><br><span class="line">  <span class="comment">// are based on the document&#x27;s URL</span></span><br><span class="line">  <span class="keyword">const</span> base = context.createElement(<span class="string">&#x27;base&#x27;</span>)</span><br><span class="line">  base.href = <span class="built_in">document</span>.location.href</span><br><span class="line">  context.head.appendChild(base)</span><br><span class="line"></span><br><span class="line">  context.body.innerHTML = string</span><br><span class="line">  <span class="keyword">return</span> context.body.children</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>parseJSON</code> 传入格式正确的 JSON 字符串并返回 JavaScript 值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.parseJSON(str)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(str)</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 代表异步操作的最终结果。jQuery 用它自己的方式处理 Promise，原生 JavaScript 遵循 Promises/A+ 标准实现了最小 API 来处理 Promise。</p><h3 id="Done-Fail-Always"><a href="#Done-Fail-Always" class="headerlink" title="Done/Fail/Always"></a>Done/Fail/Always</h3><p><code>done</code> 会在 Promise 解决时调用，<code>fail</code> 会在 Promise 拒绝时调用，<code>always</code> 总会调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$promise</span><br><span class="line">  .done(doneCallback)</span><br><span class="line">  .fail(failCallback)</span><br><span class="line">  .always(alwaysCallback)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">promise.then(doneCallback, failCallback).then(alwaysCallback, alwaysCallback)</span><br></pre></td></tr></table></figure><h3 id="When"><a href="#When" class="headerlink" title="When"></a>When</h3><p><code>when</code> 用于处理多个 Promises，当全部 Promise 被解决时返回，当任一 Promise 被拒绝时拒绝：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.when($promise1, $promise2).done(<span class="function">(<span class="params">promise1Result, promise2Result</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="built_in">Promise</span>.all([$promise1, $promise2]).then([promise1Result, promise2Result] =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><h3 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred"></a>Deferred</h3><p>Deferred 是创建 Promise 的一种方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> defer = <span class="keyword">new</span> $.Deferred()</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      defer.resolve(<span class="string">&#x27;some_value_computed_asynchronously&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      defer.reject(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> defer.promise()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;some_value_computed_asynchronously&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Deferred way</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> deferred = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    deferred.resolve = resolve</span><br><span class="line">    deferred.reject = reject</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  deferred.promise = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> deferred</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> defer = defer()</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      defer.resolve(<span class="string">&#x27;some_value_computed_asynchronously&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      defer.reject(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> defer.promise()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><h3 id="Show-Hide"><a href="#Show-Hide" class="headerlink" title="Show/Hide"></a>Show/Hide</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.show()</span><br><span class="line">$el.hide()</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.style.display = <span class="string">&#x27;&#x27;</span> | <span class="string">&#x27;inline&#x27;</span> | <span class="string">&#x27;inline-block&#x27;</span> | <span class="string">&#x27;inline-table&#x27;</span> | <span class="string">&#x27;block&#x27;</span></span><br><span class="line">el.style.display = <span class="string">&#x27;none&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Toggle"><a href="#Toggle" class="headerlink" title="Toggle"></a>Toggle</h3><p>显示/隐藏元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.toggle()</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="keyword">if</span> (el.ownerDocument.defaultView.getComputedStyle(el, <span class="literal">null</span>).display === <span class="string">&#x27;none&#x27;</span>) &#123;</span><br><span class="line">  el.style.display = <span class="string">&#x27;&#x27;</span> | <span class="string">&#x27;inline&#x27;</span> | <span class="string">&#x27;inline-block&#x27;</span> | <span class="string">&#x27;inline-table&#x27;</span> | <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  el.style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FadeIn-FadeOut"><a href="#FadeIn-FadeOut" class="headerlink" title="FadeIn/FadeOut"></a>FadeIn/FadeOut</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.fadeIn(<span class="number">3000</span>)</span><br><span class="line">$el.fadeOut(<span class="number">3000</span>)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.style.transition = <span class="string">&#x27;opacity 3s&#x27;</span></span><br><span class="line"><span class="comment">// fadeIn</span></span><br><span class="line">el.style.opacity = <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="comment">// fadeOut</span></span><br><span class="line">el.style.opacity = <span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="FadeTo"><a href="#FadeTo" class="headerlink" title="FadeTo"></a>FadeTo</h3><p>调整元素透明度：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.fadeTo(<span class="string">&#x27;slow&#x27;</span>, <span class="number">0.15</span>)</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.style.transition = <span class="string">&#x27;opacity 3s&#x27;</span> <span class="comment">// 假设 &#x27;slow&#x27; 等于 3 秒</span></span><br><span class="line">el.style.opacity = <span class="string">&#x27;0.15&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="FadeToggle"><a href="#FadeToggle" class="headerlink" title="FadeToggle"></a>FadeToggle</h3><p>调整透明度切换显示/隐藏：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.fadeToggle()</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.style.transition = <span class="string">&#x27;opacity 3s&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; opacity &#125; = el.ownerDocument.defaultView.getComputedStyle(el, <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">if</span> (opacity === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">  el.style.opacity = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  el.style.opacity = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SlideUp-SlideDown"><a href="#SlideUp-SlideDown" class="headerlink" title="SlideUp/SlideDown"></a>SlideUp/SlideDown</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.slideUp()</span><br><span class="line">$el.slideDown()</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="keyword">const</span> originHeight = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">el.style.transition = <span class="string">&#x27;height 3s&#x27;</span></span><br><span class="line"><span class="comment">// slideUp</span></span><br><span class="line">el.style.height = <span class="string">&#x27;0px&#x27;</span></span><br><span class="line"><span class="comment">// slideDown</span></span><br><span class="line">el.style.height = originHeight</span><br></pre></td></tr></table></figure><h3 id="SlideToggle"><a href="#SlideToggle" class="headerlink" title="SlideToggle"></a>SlideToggle</h3><p>滑动切换显示/隐藏：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.slideToggle()</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="keyword">const</span> originHeight = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">el.style.transition = <span class="string">&#x27;height 3s&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; height &#125; = el.ownerDocument.defaultView.getComputedStyle(el, <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">parseInt</span>(height, <span class="number">10</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">  el.style.height = originHeight</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  el.style.height = <span class="string">&#x27;0px&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Animate"><a href="#Animate" class="headerlink" title="Animate"></a>Animate</h3><p>批量执行属性动画：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.animate(&#123; params &#125;, speed);</span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.style.transition = <span class="string">&#x27;all &#x27;</span> + speed;</span><br><span class="line"><span class="built_in">Object</span>.keys(params).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span></span><br><span class="line">  el.style[key] = params[key];</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2017/02/20/frontend/170220/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2017/02/20/frontend/170220/" class="post-title-link" itemprop="url">前端知识总结-框架基础</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-02-20 00:00:00" itemprop="dateCreated datePublished" datetime="2017-02-20T00:00:00+08:00">2017-02-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 15:57:04" itemprop="dateModified" datetime="2020-11-18T15:57:04+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>14k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>13 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM 由以下三部分组成：</p><ul><li>View：界面</li><li>Model：数据模型</li><li>ViewModel：作为桥梁负责沟通 View 和 Model</li></ul><p>在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合。</p><p>在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。</p><p>在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。</p><h3 id="脏数据检测"><a href="#脏数据检测" class="headerlink" title="脏数据检测"></a>脏数据检测</h3><p>当触发了指定事件后会进入脏数据检测，这时会调用 <code>$digest</code> 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 <code>$watch</code> 函数，然后再次调用 <code>$digest</code> 循环直到发现没有变化。循环至少为二次 ，至多为十次。</p><p>脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数。所以低效也是相对的，这就仁者见仁智者见智了。</p><h3 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h3><p>Vue 内部使用了 <code>Object.defineProperty()</code> 来实现双向绑定，通过这个函数可以监听到 <code>set</code> 和 <code>get</code> 的事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">name</span>: <span class="string">&#x27;yck&#x27;</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="keyword">let</span> name = data.name <span class="comment">// -&gt; get value</span></span><br><span class="line">data.name = <span class="string">&#x27;yyy&#x27;</span> <span class="comment">// -&gt; change value</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断类型</span></span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;get value&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;change value&#x27;</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码简单的实现了如何监听数据的 <code>set</code> 和 <code>get</code> 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在解析如上模板代码时，遇到 <code>&#123;&#123;name&#125;&#125;</code> 就会给属性 <code>name</code> 添加发布订阅：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 Dep 解耦</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addSub</span>(<span class="params">sub</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// sub 是 Watcher 实例</span></span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局属性，通过该属性配置 Watcher</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>).innerText = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">obj, key, cb</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 将 Dep.target 指向自己</span></span><br><span class="line">    <span class="comment">// 然后触发属性的 getter 添加监听</span></span><br><span class="line">    <span class="comment">// 最后将 Dep.target 置空</span></span><br><span class="line">    Dep.target = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.cb = cb</span><br><span class="line">    <span class="built_in">this</span>.obj = obj</span><br><span class="line">    <span class="built_in">this</span>.key = key</span><br><span class="line">    <span class="built_in">this</span>.value = obj[key]</span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得新值</span></span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.obj[<span class="built_in">this</span>.key]</span><br><span class="line">    <span class="comment">// 调用 update 方法更新 Dom</span></span><br><span class="line">    <span class="built_in">this</span>.cb(<span class="built_in">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">name</span>: <span class="string">&#x27;yck&#x27;</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="comment">// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作</span></span><br><span class="line"><span class="keyword">new</span> Watcher(data, <span class="string">&#x27;name&#x27;</span>, update)</span><br><span class="line"><span class="comment">// update Dom innerText</span></span><br><span class="line">data.name = <span class="string">&#x27;yyy&#x27;</span></span><br></pre></td></tr></table></figure><p>接下来,对 <code>defineReactive</code> 函数进行改造：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;get value&#x27;</span>)</span><br><span class="line">      <span class="comment">// 将 Watcher 添加到订阅</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dp.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;change value&#x27;</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">      <span class="comment">// 执行 watcher 的 update 方法</span></span><br><span class="line">      dp.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 <code>getter</code> 来实现发布订阅的添加。</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p><code>Object.defineProperty</code> 虽然已经能够实现双向绑定了，但是他还是有缺陷的。</p><ul><li>只能对属性进行数据劫持，所以需要深度遍历整个对象</li><li>对于数组不能监听到数据的变化</li></ul><p>虽然 Vue 中确实能检测到数组数据的变化，但是其实是使用了 <code>hack</code> 的办法，并且也是有缺陷的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"><span class="comment">// hack 以下几个函数</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>, <span class="string">&#x27;sort&#x27;</span>, <span class="string">&#x27;reverse&#x27;</span>]</span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获得原生函数</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用原生函数</span></span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// 触发更新</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>反观 Proxy 就没以上的问题，原生支持监听数组变化，并且可以直接对整个对象进行拦截，所以 Vue 也将在下个大版本中使用 Proxy 替换 <code>Object.defineProperty</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> onWatch = <span class="function">(<span class="params">obj, setBind, getLogger</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, property, receiver</span>)</span> &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, property, value, receiver</span>)</span> &#123;</span><br><span class="line">      setBind(value)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, property, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> value</span><br><span class="line"><span class="keyword">let</span> p = onWatch(</span><br><span class="line">  obj,</span><br><span class="line">  v =&gt; &#123;</span><br><span class="line">    value = v</span><br><span class="line">  &#125;,</span><br><span class="line">  (target, property) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Get &#x27;<span class="subst">$&#123;property&#125;</span>&#x27; = <span class="subst">$&#123;target[property]&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">p.a = <span class="number">2</span> <span class="comment">// bind `value` to `2`</span></span><br><span class="line">p.a <span class="comment">// -&gt; Get &#x27;a&#x27; = 2</span></span><br></pre></td></tr></table></figure><h2 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h2><p>前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式：</p><ul><li><code>hash</code> 模式</li><li><code>history</code> 模式</li></ul><p><code>www.test.com/##/</code> 就是 Hash URL，当 <code>##</code> 后面的哈希值发生变化时，不会向服务器请求数据，可以通过 <code>hashchange</code> 事件来监听到 URL 的变化，从而进行跳转页面。</p><p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043729.png" alt="hash路由"></p><p>History 模式是 HTML5 新推出的功能，比之 Hash URL 更加美观。</p><p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043731.png" alt="history路由"></p><h2 id="Virtual-Dom"><a href="#Virtual-Dom" class="headerlink" title="Virtual Dom"></a>Virtual Dom</h2><h3 id="Virtual-Dom-特性"><a href="#Virtual-Dom-特性" class="headerlink" title="Virtual Dom 特性"></a>Virtual Dom 特性</h3><p>众所周知，操作 DOM 是很耗费性能的一件事情，既然如此，我们可以考虑通过 JS 对象来模拟 DOM 对象，毕竟操作 JS 对象比操作 DOM 省时的多：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设这里模拟一个 ul，其中包含了 5 个 li</span></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>][</span><br><span class="line">  <span class="comment">// 这里替换上面的 li</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>从上述例子中，我们一眼就可以看出先前的 <code>ul</code> 中的第三个 <code>li</code> 被移除了，四五替换了位置。</p><p>如果以上操作对应到 DOM 中，那么就是以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除第三个 li</span></span><br><span class="line">ul.childNodes[<span class="number">2</span>].remove()</span><br><span class="line"><span class="comment">// 将第四个 li 和第五个交换位置</span></span><br><span class="line"><span class="keyword">let</span> fromNode = ul.childNodes[<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> toNode = node.childNodes[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> cloneFromNode = fromNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">let</span> cloenToNode = toNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line">ul.replaceChild(cloneFromNode, toNode)</span><br><span class="line">ul.replaceChild(cloenToNode, fromNode)</span><br></pre></td></tr></table></figure><p>当然在实际操作中，我们还需要给每个节点一个标识，作为判断是同一个节点的依据。所以这也是 Vue 和 React 中官方推荐列表里的节点使用唯一的 <code>key</code> 来保证性能。</p><p>那么既然 DOM 对象可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM，以下是一个 JS 对象模拟 DOM 对象的简单实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>tag &#x27;div&#x27;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>props &#123; class: &#x27;item&#x27; &#125;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> </span>children [ Element1, &#x27;text&#x27;]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>key option</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">tag, props, children, key</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.tag = tag</span><br><span class="line">    <span class="built_in">this</span>.props = props</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.children = children</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isString(children)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.key = children</span><br><span class="line">      <span class="built_in">this</span>.children = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key) <span class="built_in">this</span>.key = key</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 渲染</span></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> root = <span class="built_in">this</span>._createElement(<span class="built_in">this</span>.tag, <span class="built_in">this</span>.props, <span class="built_in">this</span>.children, <span class="built_in">this</span>.key)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(root)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">create</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._createElement(<span class="built_in">this</span>.tag, <span class="built_in">this</span>.props, <span class="built_in">this</span>.children, <span class="built_in">this</span>.key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建节点</span></span><br><span class="line">  <span class="function"><span class="title">_createElement</span>(<span class="params">tag, props, child, key</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 tag 创建节点</span></span><br><span class="line">    <span class="keyword">let</span> el = <span class="built_in">document</span>.createElement(tag)</span><br><span class="line">    <span class="comment">// 设置节点属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">if</span> (props.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="keyword">const</span> value = props[key]</span><br><span class="line">        el.setAttribute(key, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">      el.setAttribute(<span class="string">&#x27;key&#x27;</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归添加子节点</span></span><br><span class="line">    <span class="keyword">if</span> (child) &#123;</span><br><span class="line">      child.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> child</span><br><span class="line">        <span class="keyword">if</span> (element <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">          child = <span class="built_in">this</span>._createElement(element.tag, element.props, element.children, element.key)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          child = <span class="built_in">document</span>.createTextNode(element)</span><br><span class="line">        &#125;</span><br><span class="line">        el.appendChild(child)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> el</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Virtual-Dom-简述"><a href="#Virtual-Dom-简述" class="headerlink" title="Virtual Dom 简述"></a>Virtual Dom 简述</h3><p>既然我们已经通过 JS 来模拟实现了 DOM，那么接下来的难点就在于如何判断旧的对象和新的对象之间的差异。</p><p>DOM 是多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 <code>O(n^3)</code>，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 <code>O(n)</code> 的复杂度来对比差异。</p><p>实现 <code>O(n)</code> 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素。</p><p>所以判断差异的算法就分为了两步：</p><ol><li>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异</li><li>一旦节点有子元素，就去判断子元素是否有不同</li></ol><h3 id="Virtual-Dom-实现"><a href="#Virtual-Dom-实现" class="headerlink" title="Virtual Dom 实现"></a>Virtual Dom 实现</h3><h4 id="树的递归"><a href="#树的递归" class="headerlink" title="树的递归"></a>树的递归</h4><p>首先我们来实现树的递归算法，在实现该算法前，先来考虑下两个节点对比会有几种情况：</p><ul><li>新的节点的 <code>tagName</code> 或者 <code>key</code> 和旧的不同，这种情况代表需要替换旧的节点，并且也不再需要遍历新旧节点的子元素了，因为整个旧节点都被删掉了</li><li>新的节点的 <code>tagName</code> 和 <code>key</code>（可能都没有）和旧的相同，开始遍历子树</li><li>没有新的节点，那么什么都不用做</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StateEnums, isString, move &#125; <span class="keyword">from</span> <span class="string">&#x27;./util&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Element <span class="keyword">from</span> <span class="string">&#x27;./element&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">oldDomTree, newDomTree</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用于记录差异</span></span><br><span class="line">  <span class="keyword">let</span> pathchs = &#123;&#125;</span><br><span class="line">  <span class="comment">// 一开始的索引为 0</span></span><br><span class="line">  dfs(oldDomTree, newDomTree, <span class="number">0</span>, pathchs)</span><br><span class="line">  <span class="keyword">return</span> pathchs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">oldNode, newNode, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用于保存子树的更改</span></span><br><span class="line">  <span class="keyword">let</span> curPatches = []</span><br><span class="line">  <span class="comment">// 需要判断三种情况</span></span><br><span class="line">  <span class="comment">// 1.没有新的节点，那么什么都不用做</span></span><br><span class="line">  <span class="comment">// 2.新的节点的 tagName 和 `key` 和旧的不同，就替换</span></span><br><span class="line">  <span class="comment">// 3.新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历子树</span></span><br><span class="line">  <span class="keyword">if</span> (!newNode) &#123;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNode.tag === oldNode.tag &amp;&amp; newNode.key === oldNode.key) &#123;</span><br><span class="line">    <span class="comment">// 判断属性是否变更</span></span><br><span class="line">    <span class="keyword">let</span> props = diffProps(oldNode.props, newNode.props)</span><br><span class="line">    <span class="keyword">if</span> (props.length) curPatches.push(&#123; <span class="attr">type</span>: StateEnums.ChangeProps, props &#125;)</span><br><span class="line">    <span class="comment">// 遍历子树</span></span><br><span class="line">    diffChildren(oldNode.children, newNode.children, index, patches)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 节点不同，需要替换</span></span><br><span class="line">    curPatches.push(&#123; <span class="attr">type</span>: StateEnums.Replace, <span class="attr">node</span>: newNode &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (curPatches.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (patches[index]) &#123;</span><br><span class="line">      patches[index] = patches[index].concat(curPatches)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      patches[index] = curPatches</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性更改"><a href="#属性更改" class="headerlink" title="属性更改"></a>属性更改</h4><p>判断属性的更改也分三个步骤：</p><ol><li>遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中</li><li>遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化</li><li>在第二步中同时查看是否有属性不存在与旧的属性列列表中</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffProps</span>(<span class="params">oldProps, newProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断 Props 分以下三步骤</span></span><br><span class="line">  <span class="comment">// 先遍历 oldProps 查看是否存在删除的属性</span></span><br><span class="line">  <span class="comment">// 然后遍历 newProps 查看是否有属性值被修改</span></span><br><span class="line">  <span class="comment">// 最后查看是否有属性新增</span></span><br><span class="line">  <span class="keyword">let</span> change = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldProps.hasOwnProperty(key) &amp;&amp; !newProps[key]) &#123;</span><br><span class="line">      change.push(&#123;</span><br><span class="line">        prop: key</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newProps.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="keyword">const</span> prop = newProps[key]</span><br><span class="line">      <span class="keyword">if</span> (oldProps[key] &amp;&amp; oldProps[key] !== newProps[key]) &#123;</span><br><span class="line">        change.push(&#123;</span><br><span class="line">          prop: key,</span><br><span class="line">          value: newProps[key]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!oldProps[key]) &#123;</span><br><span class="line">        change.push(&#123;</span><br><span class="line">          prop: key,</span><br><span class="line">          value: newProps[key]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> change</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="列表差异"><a href="#列表差异" class="headerlink" title="列表差异"></a>列表差异</h4><p>这个算法是整个 Virtual Dom 中最核心的算法，且让我一一为你道来。 这里的主要步骤其实和判断属性差异是类似的，也是分为三步：</p><ol><li>遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中</li><li>遍历新的节点列表，判断是否有新的节点</li><li>在第二步中同时判断节点是否有移动</li></ol><p>该算法只对有 <code>key</code> 的节点做处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listDiff</span>(<span class="params">oldList, newList, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为了遍历方便，先取出两个 list 的所有 keys</span></span><br><span class="line">  <span class="keyword">let</span> oldKeys = getKeys(oldList)</span><br><span class="line">  <span class="keyword">let</span> newKeys = getKeys(newList)</span><br><span class="line">  <span class="keyword">let</span> changes = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于保存变更后的节点数据</span></span><br><span class="line">  <span class="comment">// 使用该数组保存有以下好处</span></span><br><span class="line">  <span class="comment">// 1.可以正确获得被删除节点索引</span></span><br><span class="line">  <span class="comment">// 2.交换节点位置只需要操作一遍 DOM</span></span><br><span class="line">  <span class="comment">// 3.用于 `diffChildren` 函数中的判断，只需要遍历</span></span><br><span class="line">  <span class="comment">// 两个树中都存在的节点，而对于新增或者删除的节点来说，完全没必要</span></span><br><span class="line">  <span class="comment">// 再去判断一遍</span></span><br><span class="line">  <span class="keyword">let</span> list = []</span><br><span class="line">  oldList &amp;&amp;</span><br><span class="line">    oldList.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> key = item.key</span><br><span class="line">      <span class="keyword">if</span> (isString(item)) &#123;</span><br><span class="line">        key = item</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 寻找新的 children 中是否含有当前节点</span></span><br><span class="line">      <span class="comment">// 没有的话需要删除</span></span><br><span class="line">      <span class="keyword">let</span> index = newKeys.indexOf(key)</span><br><span class="line">      <span class="keyword">if</span> (index === -<span class="number">1</span>) &#123;</span><br><span class="line">        list.push(<span class="literal">null</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> list.push(key)</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="comment">// 遍历变更后的数组</span></span><br><span class="line">  <span class="keyword">let</span> length = list.length</span><br><span class="line">  <span class="comment">// 因为删除数组元素是会更改索引的</span></span><br><span class="line">  <span class="comment">// 所有从后往前删可以保证索引不变</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 判断当前元素是否为空，为空表示需要删除</span></span><br><span class="line">    <span class="keyword">if</span> (!list[i]) &#123;</span><br><span class="line">      list.splice(i, <span class="number">1</span>)</span><br><span class="line">      changes.push(&#123;</span><br><span class="line">        type: StateEnums.Remove,</span><br><span class="line">        index: i</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历新的 list，判断是否有节点新增或移动</span></span><br><span class="line">  <span class="comment">// 同时也对 `list` 做节点新增和移动节点的操作</span></span><br><span class="line">  newList &amp;&amp;</span><br><span class="line">    newList.forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> key = item.key</span><br><span class="line">      <span class="keyword">if</span> (isString(item)) &#123;</span><br><span class="line">        key = item</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 寻找旧的 children 中是否含有当前节点</span></span><br><span class="line">      <span class="keyword">let</span> index = list.indexOf(key)</span><br><span class="line">      <span class="comment">// 没找到代表新节点，需要插入</span></span><br><span class="line">      <span class="keyword">if</span> (index === -<span class="number">1</span> || key == <span class="literal">null</span>) &#123;</span><br><span class="line">        changes.push(&#123;</span><br><span class="line">          type: StateEnums.Insert,</span><br><span class="line">          node: item,</span><br><span class="line">          index: i</span><br><span class="line">        &#125;)</span><br><span class="line">        list.splice(i, <span class="number">0</span>, key)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到了，需要判断是否需要移动</span></span><br><span class="line">        <span class="keyword">if</span> (index !== i) &#123;</span><br><span class="line">          changes.push(&#123;</span><br><span class="line">            type: StateEnums.Move,</span><br><span class="line">            <span class="keyword">from</span>: index,</span><br><span class="line">            to: i</span><br><span class="line">          &#125;)</span><br><span class="line">          move(list, index, i)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123; changes, list &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKeys</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = []</span><br><span class="line">  <span class="keyword">let</span> text</span><br><span class="line">  list &amp;&amp;</span><br><span class="line">    list.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> key</span><br><span class="line">      <span class="keyword">if</span> (isString(item)) &#123;</span><br><span class="line">        key = [item]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        key = item.key</span><br><span class="line">      &#125;</span><br><span class="line">      keys.push(key)</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="keyword">return</span> keys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标识子元素"><a href="#标识子元素" class="headerlink" title="标识子元素"></a>标识子元素</h4><p>对于这个函数来说，主要功能就两个：</p><ol><li>判断两个列表差异</li><li>给节点打上标记</li></ol><p>总体来说，该函数实现的功能很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">oldChild, newChild, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; changes, list &#125; = listDiff(oldChild, newChild, index, patches)</span><br><span class="line">  <span class="keyword">if</span> (changes.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (patches[index]) &#123;</span><br><span class="line">      patches[index] = patches[index].concat(changes)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      patches[index] = changes</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录上一个遍历过的节点</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="literal">null</span></span><br><span class="line">  oldChild &amp;&amp;</span><br><span class="line">    oldChild.forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> child = item &amp;&amp; item.children</span><br><span class="line">      <span class="keyword">if</span> (child) &#123;</span><br><span class="line">        index = last &amp;&amp; last.children ? index + last.children.length + <span class="number">1</span> : index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> keyIndex = list.indexOf(item.key)</span><br><span class="line">        <span class="keyword">let</span> node = newChild[keyIndex]</span><br><span class="line">        <span class="comment">// 只遍历新旧中都存在的节点，其他新增或者删除的没必要遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">          dfs(item, node, index, patches)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> index += <span class="number">1</span></span><br><span class="line">      last = item</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="渲染差异"><a href="#渲染差异" class="headerlink" title="渲染差异"></a>渲染差异</h4><p>通过之前的算法，我们已经可以得出两个树的差异了。既然知道了差异，就需要局部去更新 DOM 了，下面就让我们来看看 Virtual Dom 算法的最后一步骤</p><p>这个函数主要两个功能：</p><ol><li>深度遍历树，将需要做变更操作的取出来</li><li>局部更新 DOM</li></ol><p>整体来说这部分代码还是很好理解的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">node, patchs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> changes = patchs[index]</span><br><span class="line">  <span class="keyword">let</span> childNodes = node &amp;&amp; node.childNodes</span><br><span class="line">  <span class="comment">// 这里的深度遍历和 diff 中是一样的</span></span><br><span class="line">  <span class="keyword">if</span> (!childNodes) index += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> (changes &amp;&amp; changes.length &amp;&amp; patchs[index]) &#123;</span><br><span class="line">    changeDom(node, changes)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> last = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (childNodes &amp;&amp; childNodes.length) &#123;</span><br><span class="line">    childNodes.forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">      index = last &amp;&amp; last.children ? index + last.children.length + <span class="number">1</span> : index + <span class="number">1</span></span><br><span class="line">      patch(item, patchs)</span><br><span class="line">      last = item</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeDom</span>(<span class="params">node, changes, noChild</span>) </span>&#123;</span><br><span class="line">  changes &amp;&amp;</span><br><span class="line">    changes.forEach(<span class="function"><span class="params">change</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; type &#125; = change</span><br><span class="line">      <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> StateEnums.ChangeProps:</span><br><span class="line">          <span class="keyword">let</span> &#123; props &#125; = change</span><br><span class="line">          props.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.value) &#123;</span><br><span class="line">              node.setAttribute(item.prop, item.value)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              node.removeAttribute(item.prop)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Remove:</span><br><span class="line">          node.childNodes[change.index].remove()</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Insert:</span><br><span class="line">          <span class="keyword">let</span> dom</span><br><span class="line">          <span class="keyword">if</span> (isString(change.node)) &#123;</span><br><span class="line">            dom = <span class="built_in">document</span>.createTextNode(change.node)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (change.node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            dom = change.node.create()</span><br><span class="line">          &#125;</span><br><span class="line">          node.insertBefore(dom, node.childNodes[change.index])</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Replace:</span><br><span class="line">          node.parentNode.replaceChild(change.node.create(), node)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Move:</span><br><span class="line">          <span class="keyword">let</span> fromNode = node.childNodes[change.from]</span><br><span class="line">          <span class="keyword">let</span> toNode = node.childNodes[change.to]</span><br><span class="line">          <span class="keyword">let</span> cloneFromNode = fromNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line">          <span class="keyword">let</span> cloenToNode = toNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line">          node.replaceChild(cloneFromNode, toNode)</span><br><span class="line">          node.replaceChild(cloenToNode, fromNode)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Virtual-Dom-总结"><a href="#Virtual-Dom-总结" class="headerlink" title="Virtual Dom 总结"></a>Virtual Dom 总结</h3><p>Virtual Dom 算法的实现也就是以下三步：</p><ol><li>通过 JS 来模拟创建 DOM 对象</li><li>判断两个对象的差异</li><li>渲染差异</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test4 = <span class="keyword">new</span> Element(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;my-div&#x27;</span> &#125;, [<span class="string">&#x27;test4&#x27;</span>])</span><br><span class="line"><span class="keyword">let</span> test5 = <span class="keyword">new</span> Element(<span class="string">&#x27;ul&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;my-div&#x27;</span> &#125;, [<span class="string">&#x27;test5&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test1 = <span class="keyword">new</span> Element(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;my-div&#x27;</span> &#125;, [test4])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test2 = <span class="keyword">new</span> Element(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;11&#x27;</span> &#125;, [test5, test4])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> root = test1.render()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pathchs = diff(test1, test2)</span><br><span class="line"><span class="built_in">console</span>.log(pathchs)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;开始更新&#x27;</span>)</span><br><span class="line">  patch(root, pathchs)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;结束更新&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>当然目前的实现还略显粗糙，但是对于理解 Virtual Dom 算法来说已经是完全足够的了。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2017/02/14/frontend/170214/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2017/02/14/frontend/170214/" class="post-title-link" itemprop="url">前端知识总结-性能优化</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-02-14 00:00:00" itemprop="dateCreated datePublished" datetime="2017-02-14T00:00:00+08:00">2017-02-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 15:57:05" itemprop="dateModified" datetime="2020-11-18T15:57:05+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>3.4k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>3 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><h3 id="缓存方式"><a href="#缓存方式" class="headerlink" title="缓存方式"></a>缓存方式</h3><p>缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。</p><p>通常浏览器缓存策略分为两种：强缓存和协商缓存。</p><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>实现强缓存可以通过两种响应头实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，<code>state code</code> 为 200：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, <span class="number">22</span> Oct <span class="number">2018</span> <span class="number">0</span>8:<span class="number">41</span>:<span class="number">0</span>0 GMT</span><br></pre></td></tr></table></figure><p>Expires 是 <code>HTTP / 1.0</code> 的产物，表示资源会在 <code>Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-control: max-age=<span class="number">30</span></span><br></pre></td></tr></table></figure><p>Cache-Control 出现于 <code>HTTP / 1.1</code>，优先级高于 Expires 。该属性表示资源会在 <code>30</code> 秒后过期，需要再次请求。</p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。</p><p>协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。</p><h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h5><p><code>Last-Modified</code> 表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified</code> 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。</p><p>但是如果在本地打开缓存文件，就会造成 <code>Last-Modified</code> 被修改，所以在 <code>HTTP / 1.1</code> 出现了 <code>ETag</code> 。</p><h5 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h5><p>ETag 类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code> 发送给服务器，询问该资源 <code>ETag</code> 是否变动，有变动的话就将新的资源发送回来。并且 <code>ETag</code> 优先级比 <code>Last-Modified</code> 高。</p><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略：</p><ul><li>对于某些不需要缓存的资源，可以使用 <code>Cache-control: no-store</code> ，表示该资源不需要缓存</li><li>对于频繁变动的资源，可以使用 <code>Cache-Control: no-cache</code> 并配合 <code>ETag</code> 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li><li>对于代码文件来说，通常使用 <code>Cache-Control: max-age=31536000</code> 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li></ul><h1 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h1><p>因为浏览器会有并发请求限制，在 <code>HTTP / 1.1</code> 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。</p><p>在 <code>HTTP / 2.0</code> 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。</p><h3 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h3><p>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//yuchengkai.cn&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。</p><p>预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用以下代码开启预加载：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</p><h3 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h3><p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prerender&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染</p><h2 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h2><p>对于代码层面的优化，你可以查阅浏览器系列中的 <a target="_blank" rel="noopener" href="https://yuchengkai.cn/docs/Browser/browser-ch.html##%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6">相关内容</a>。</p><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>懒加载就是将不关键的资源延后加载。</p><p>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。</p><p>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。</p><h3 id="懒执行"><a href="#懒执行" class="headerlink" title="懒执行"></a>懒执行</h3><p>懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。</p><h2 id="文件优化"><a href="#文件优化" class="headerlink" title="文件优化"></a>文件优化</h2><h3 id="图片文件"><a href="#图片文件" class="headerlink" title="图片文件"></a>图片文件</h3><h4 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h4><p>对于一张 <code>100x100</code> 像素的图片来说，图像上有 <code>10000</code> 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1 个字节），所以该图片大小大概为 <code>39KB（10000 _ 1 \* 4 / 1024）</code>。</p><p>但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。</p><p>了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了：</p><ul><li>减少像素点</li><li>减少每个像素点能够显示的颜色</li></ul><h4 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h4><ul><li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</li><li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加 载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li><li>小图使用 <code>base64</code> 格式</li><li>将多个图标文件整合到一张图片中（雪碧图）</li><li>选择正确的图片格式：<ul><li>对于能够显示 <code>WebP</code> 格式的浏览器尽量使用 <code>WebP</code> 格式。因为 <code>WebP</code> 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li><li>小图使用 <code>PNG</code>，其实对于大部分图标这类图片，完全可以使用 <code>SVG</code> 代替</li><li>照片使用 <code>JPEG</code></li></ul></li></ul><h3 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h3><ul><li>CSS 文件放在 <code>head</code> 中</li><li>服务端开启文件压缩功能</li><li>将 <code>script</code> 标签放在 <code>body</code> 底部，因为 JS 文件执行会阻塞渲染。当然也可以把<code>script</code> 标签放在任意位置然后加上 <code>defer</code> ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 <code>async</code> ，表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行。</li><li>执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 <code>Webworker</code>，<code>Webworker</code> 可以让我们另开一个线程执行脚本而不影响渲染。</li></ul><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。</p><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><h3 id="Webpack-配置"><a href="#Webpack-配置" class="headerlink" title="Webpack 配置"></a>Webpack 配置</h3><ul><li>对于 Webpack4，打包项目使用 <code>production</code> 模式，这样会自动开启代码压缩</li><li>使用 ES6 模块来开启 <code>tree shaking</code>，这个技术可以移除没有使用的代码</li><li>优化图片，对于小图可以使用 <code>base64</code> 的方式写入文件中</li><li>按照路由拆分代码，实现按需加载</li><li>给打包出来的文件名添加哈希，实现浏览器缓存文件</li></ul><h3 id="错误拦截"><a href="#错误拦截" class="headerlink" title="错误拦截"></a>错误拦截</h3><p>对于代码运行错误，通常的办法是使用 <code>window.onerror</code> 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外：</p><ul><li>对于跨域的代码运行错误会显示 <code>script error</code>. 对于这种情况我们需要给 <code>script</code> 标签添加 <code>crossorigin</code> 属性</li><li>对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 <code>arguments.callee.caller</code> 来做栈递归</li><li>对于异步代码来说，可以使用 <code>catch</code> 的方式捕获错误。比如 <code>Promis</code>e 可以直接使用 <code>catch</code> 函数，<code>async await</code>可以使用 <code>try catch</code></li></ul><p>但是要注意线上运行的代码都是压缩过的，需要在打包时生成 <code>sourceMap</code> 文件便于 <code>debug</code>，对于捕获的错误需要上传给服务器，通常可以通过 <code>img</code> 标签的 <code>src</code> 发起一个请求。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2017/02/07/frontend/170207/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2017/02/07/frontend/170207/" class="post-title-link" itemprop="url">前端知识总结-网络安全</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-02-07 00:00:00" itemprop="dateCreated datePublished" datetime="2017-02-07T00:00:00+08:00">2017-02-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 15:57:05" itemprop="dateModified" datetime="2020-11-18T15:57:05+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>3.2k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>3 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><blockquote><p>跨站指令码（全称 Cross-site scripting）是一种网站应用程式的安全漏洞攻击，是代码注入的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。</p></blockquote><p>XSS 分为三种：反射型，存储型和 DOM-based 型</p><h3 id="如何攻击"><a href="#如何攻击" class="headerlink" title="如何攻击"></a>如何攻击</h3><p>XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。</p><p>例如通过 URL 获取某些参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述 URL 输入可能会将 HTML 改为 <code>&lt;div&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/div&gt;</code> ，这样页面中就凭空多了一段可执行脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻击。</p><p>也有另一种场景，比如写了一篇包含攻击代码 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 的文章，那么可能浏览文章的用户都会被攻击到。这种攻击类型是存储型攻击，也可以说是 DOM-based 攻击，并且这种攻击打击面更广。</p><h3 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h3><p>最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">&#x27;&amp;amp;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">&#x27;&amp;lt;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">&#x27;&amp;gt;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;&amp;quto;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&amp;#39;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/`/g</span>, <span class="string">&#x27;&amp;#96;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/\//g</span>, <span class="string">&#x27;&amp;#x2F;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过转义可以将攻击代码 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 变成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt;</span></span><br><span class="line"><span class="built_in">escape</span>(<span class="string">&#x27;&lt;script&gt;alert(1)&lt;/script&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xss = <span class="built_in">require</span>(<span class="string">&#x27;xss&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> html = xss(<span class="string">&#x27;&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert(&quot;xss&quot;);&amp;lt;/script&amp;gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(html)</span><br></pre></td></tr></table></figure><p>以上示例使用了 <code>js-xss</code> 来实现。可以看到在输出中保留了 <code>h1</code> 标签且过滤了 <code>script</code> 标签。</p><h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><blockquote><p>内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。</p></blockquote><p>我们可以通过 CSP 来尽量减少 XSS 攻击。CSP 本质上也是建立白名单，规定了浏览器只能够执行特定来源的代码。</p><p>通常可以通过 HTTP Header 中的 Content-Security-Policy 来开启 CSP：</p><ul><li><p>只允许加载本站资源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src ‘self’</span><br></pre></td></tr></table></figure></li><li><p>只允许加载 HTTPS 协议图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: img-src https:&#x2F;&#x2F;*</span><br></pre></td></tr></table></figure></li><li><p>允许加载任何来源框架：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: child-src &#39;none&#39;</span><br></pre></td></tr></table></figure></li></ul><p>更多属性可以查看 <a target="_blank" rel="noopener" href="https://content-security-policy.com/">这里</a>。</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><blockquote><p>跨站请求伪造（全称 Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。跨站请求伪造和跨站指令码（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p></blockquote><p>简单点说，CSRF 就是利用用户的登录态发起恶意请求。</p><h3 id="如何攻击-1"><a href="#如何攻击-1" class="headerlink" title="如何攻击"></a>如何攻击</h3><p>假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://www.domain.com/xxx?comment=&#x27;attack&#x27;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>如果接口是 Post 提交的，就相对麻烦点，需要用表单来提交接口：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://www.domain.com/xxx&quot;</span> <span class="attr">id</span>=<span class="string">&quot;CSRF&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;comment&quot;</span> <span class="attr">value</span>=<span class="string">&quot;attack&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="如何防御-1"><a href="#如何防御-1" class="headerlink" title="如何防御"></a>如何防御</h3><p>防范 CSRF 可以遵循以下几种规则：</p><ul><li>Get 请求不对数据进行修改</li><li>不让第三方网站访问到用户 Cookie</li><li>阻止第三方网站请求接口</li><li>请求时附带验证信息，比如验证码或者 Token</li></ul><h4 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h4><p>可以对 Cookie 设置 SameSite 属性。该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。</p><h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><p>对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。</p><h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>服务器下发一个随机 Token（算法不能复杂），每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。</p><h2 id="密码安全"><a href="#密码安全" class="headerlink" title="密码安全"></a>密码安全</h2><p>密码安全虽然大多是后端的事情，但是作为一名优秀的前端程序员也需要熟悉这方面的知识。</p><h3 id="加盐"><a href="#加盐" class="headerlink" title="加盐"></a>加盐</h3><p>对于密码存储来说，必然是不能明文存储在数据库中的，否则一旦数据库泄露，会对用户造成很大的损失。并且不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系。</p><p>通常需要对密码加盐，然后进行几次不同加密算法的加密：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加盐也就是给原密码添加字符串，增加原密码长度</span></span><br><span class="line">sha256(sha1(md5(salt + password + salt)))</span><br></pre></td></tr></table></figure><p>但是加盐并不能阻止别人盗取账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而应该提示账号或密码错误。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2017/02/02/frontend/170202/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2017/02/02/frontend/170202/" class="post-title-link" itemprop="url">前端知识总结-事件循环</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-02-02 00:00:00" itemprop="dateCreated datePublished" datetime="2017-02-02T00:00:00+08:00">2017-02-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 15:57:04" itemprop="dateModified" datetime="2020-11-18T15:57:04+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>4k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>4 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点），当然可以引入读写锁解决这个问题。</p><p>JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>以上代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第二个参数不得小于 4 毫秒，不足会自动增加。所以 <code>setTimeout</code> 还是会在 <code>script end</code> 之后打印。</p><p>不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务 <code>microtask</code> 和 宏任务 <code>macrotask</code>。在 ES6 规范中，<code>microtask</code> 称为 <code>jobs</code>，<code>macrotask</code> 称为 <code>task</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></table></figure><p>以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code> 属于宏任务，所以会有以上的打印。</p><ul><li><p>微任务包括 <code>Promise</code> ，<code>process.nextTick</code> ，<code>Object.observe</code> ，<code>MutationObserver</code></p></li><li><p>宏任务包括 <code>script</code> ， <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code> ，<code>UI rendering</code></p></li></ul><p>很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 <code>script</code> ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。</p><p>所以正确的一次 Event loop 顺序是这样：</p><ol><li>执行同步代码，这属于宏任务</li><li>执行栈为空时查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染 UI</li><li>开始下一轮 Event loop，执行宏任务中的异步代码</li></ol><p>通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的 界面响应，我们可以把操作 DOM 放入微任务中。</p><h2 id="Node-事件循环"><a href="#Node-事件循环" class="headerlink" title="Node 事件循环"></a>Node 事件循环</h2><p>Node 中的 Event loop 和浏览器不同，主要分为 6 个阶段，它们会按照顺序反复运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I&#x2F;O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><p><code>timers</code> 阶段会执行 <code>setTimeout</code> 和 <code>setInterval</code>，一个 <code>timer</code> 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟。</p><p>下限的时间有一个范围：<code>[1, 2147483647]</code> ，如果设定的时间不在这个范围，将被设置为 1。</p><h3 id="I-O-callbacks"><a href="#I-O-callbacks" class="headerlink" title="I/O callbacks"></a>I/O callbacks</h3><p><code>I/O</code> 阶段会执行除了 close 事件，定时器和 <code>setImmediate</code> 的回调。</p><h3 id="idle-prepare"><a href="#idle-prepare" class="headerlink" title="idle/prepare"></a>idle/prepare</h3><p>idle/prepare 阶段内部实现。</p><h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><p><code>poll</code> 阶段很重要，这一阶段中，系统会做两件事情：</p><ol><li>执行到点的定时器</li><li>执行 <code>poll</code> 队列中的事件</li></ol><p>并且当 <code>poll</code> 中没有定时器的情况下，会发现以下两件事情：</p><ul><li>如果 <code>poll</code> 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制</li><li>如果 <code>poll</code> 队列为空，会有两件事发生<ul><li>如果有 <code>setImmediate</code> 需要执行，<code>poll</code> 阶段会停止并且进入到 <code>check</code> 阶段执行 <code>setImmediate</code></li><li>如果没有 <code>setImmediate</code> 需要执行，会等待回调被加入到队列中并立即执行回调</li><li>如果有别的定时器需要被执行，会回到 <code>timer</code> 阶段执行回调。</li></ul></li></ul><h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><p><code>check</code> 阶段执行 <code>setImmediate</code>。</p><h3 id="close-callbacks"><a href="#close-callbacks" class="headerlink" title="close callbacks"></a>close callbacks</h3><p><code>close callbacks</code> 阶段执行 <code>close</code> 事件，并且在 Node 中，有些情况下的定时器执行顺序是随机的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setImmediate&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里可能会输出 setTimeout，setImmediate</span></span><br><span class="line"><span class="comment">// 可能也会相反的输出，这取决于性能</span></span><br><span class="line"><span class="comment">// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate</span></span><br><span class="line"><span class="comment">// 否则会执行 setTimeout</span></span><br></pre></td></tr></table></figure><p>当然在这种情况下，执行顺序是相同的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(\_\_filename, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;immediate&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 因为 readFile 的回调在 poll 中执行</span></span><br><span class="line"><span class="comment">// 发现有 setImmediate ，所以会立即跳到 check 阶段执行回调</span></span><br><span class="line"><span class="comment">// 再去 timer 阶段执行 setTimeout</span></span><br><span class="line"><span class="comment">// 所以以上输出一定是 setImmediate，setTimeout</span></span><br></pre></td></tr></table></figure><p>上面介绍的都是 <code>macrotask</code> 的执行情况，<code>microtask</code> 会在以上每个阶段完成后立即执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码在浏览器和 node 中打印情况是不同的</span></span><br><span class="line"><span class="comment">// 浏览器中一定打印 timer1, promise1, timer2, promise2</span></span><br><span class="line"><span class="comment">// node 中可能打印 timer1, timer2, promise1, promise2</span></span><br><span class="line"><span class="comment">// 也可能打印 timer1, promise1, timer2, promise2</span></span><br></pre></td></tr></table></figure><p>Node 中的 <code>process.nextTick</code> 会先于其他 <code>microtask</code> 执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// nextTick, timer1, promise1</span></span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2017/01/26/frontend/170126/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2017/01/26/frontend/170126/" class="post-title-link" itemprop="url">前端知识总结-页面渲染</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-01-26 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-26T00:00:00+08:00">2017-01-26</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 15:57:05" itemprop="dateModified" datetime="2020-11-18T15:57:05+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1.2k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>浏览器的页面渲染机制一般分为以下几个步骤：</p><ol><li>处理 HTML 并构建 DOM 树。</li><li>处理 CSS 构建 CSSOM 树。</li><li>将 DOM 与 CSSOM 合并成一个渲染树。</li><li>根据渲染树来布局，计算每个节点的位置。</li><li>调用 GPU 绘制，合成图层，显示在屏幕上。</li></ol><p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043710.png" alt="浏览器渲染"></p><p>在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢。</p><p>当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。</p><h2 id="页面加载"><a href="#页面加载" class="headerlink" title="页面加载"></a>页面加载</h2><p>浏览器页面加载完成节点分为 DOMContentLoaded 和 Load 两种情况：</p><ul><li>DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。</li><li>Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。</li></ul><h2 id="图层渲染"><a href="#图层渲染" class="headerlink" title="图层渲染"></a>图层渲染</h2><p>一般来说，可以把普通文档流看成一个图层，特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。</p><p>通过以下几个常用属性可以生成新图层：</p><ul><li>will-change</li><li>position: fixed</li><li>video、iframe 标签</li><li>通过动画实现的 opacity 转换</li><li>3D 变换：translate3d、translateZ</li></ul><h2 id="重绘-回流"><a href="#重绘-回流" class="headerlink" title="重绘/回流"></a>重绘/回流</h2><p>重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。</p><ul><li>重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘</li><li>回流是布局或者几何属性需要改变就称为回流。</li></ul><p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。</p><p>所以以下几个动作可能会导致性能问题：</p><ul><li>盒模型</li><li>文字改变</li><li>字体改变</li><li>定位或者浮动</li><li>添加或删除样式</li><li>改变 window 大小</li></ul><p>很多人不知道的是，重绘和回流其实和 Event loop 有关。</p><ol><li>当 Event loop 执行完 Microtasks 后，会判断 <code>document</code> 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。</li><li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 16ms 才会触发一次，并且自带节流功能。</li><li>判断是否触发了 <code>media query</code></li><li>更新动画并且发送事件</li><li>判断是否有全屏操作事件</li><li>执行 <code>requestAnimationFrame</code> 回调</li><li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li><li>更新界面</li></ol><p>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><nav class="pagination"><a class="extend prev" rel="prev" href="/blog-hexo/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog-hexo/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog-hexo/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/blog-hexo/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/blog-hexo/page/7/">7</a><a class="extend next" rel="next" href="/blog-hexo/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="阳明先生" src="/blog-hexo/images/avatar.png"><p class="site-author-name" itemprop="name">阳明先生</p><div class="site-description" itemprop="description">知之真切笃实处即是行 行之明觉精察处即是知</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/blog-hexo/archives/"><span class="site-state-item-count">63</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/blog-hexo/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/blog-hexo/tags/"><span class="site-state-item-count">25</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/NiRongFei" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;NiRongFei" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">阳明先生</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">442k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">6:42</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/blog-hexo/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/blog-hexo/lib/velocity/velocity.min.js"></script><script src="/blog-hexo/lib/velocity/velocity.ui.min.js"></script><script src="/blog-hexo/js/utils.js"></script><script src="/blog-hexo/js/motion.js"></script><script src="/blog-hexo/js/schemes/pisces.js"></script><script src="/blog-hexo/js/next-boot.js"></script><script async src="/js/typing.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,document.body.addEventListener("input",POWERMODE)</script></body></html>