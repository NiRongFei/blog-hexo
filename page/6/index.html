<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/blog-hexo/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/blog-hexo/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/blog-hexo/images/favicon-16x16.ico"><link rel="mask-icon" href="/blog-hexo/images/logo.svg" color="#222"><link rel="stylesheet" href="/blog-hexo/css/main.css"><link rel="stylesheet" href="/blog-hexo/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.nirongfei.site",root:"/blog-hexo/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="知之真切笃实处即是行 行之明觉精察处即是知"><meta property="og:type" content="website"><meta property="og:title" content="阳明先生"><meta property="og:url" content="https://www.nirongfei.site/blog-hexo/page/6/index.html"><meta property="og:site_name" content="阳明先生"><meta property="og:description" content="知之真切笃实处即是行 行之明觉精察处即是知"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="阳明先生"><meta property="article:tag" content="阳明先生 知行合一 知之真切笃实处即是行 行之明觉精察处即是知"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.nirongfei.site/blog-hexo/page/6/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>阳明先生</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/blog-hexo/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">阳明先生</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">知行合一</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog-hexo/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/blog-hexo/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/blog-hexo/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/blog-hexo/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2016/09/13/frontend/160913/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2016/09/13/frontend/160913/" class="post-title-link" itemprop="url">Javascript学习笔记-原型</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2016-09-13 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-13T00:00:00+08:00">2016-09-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 15:57:05" itemprop="dateModified" datetime="2020-11-18T15:57:05+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>4.4k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>4 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>类和实例是大多数面向对象编程语言的基本概念，不过在 JS 中不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。原型是指当我们想要创建 xiaoming 这个具体的学生时，我们并没有一个 Student 类型可用。那怎么办？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Robot&#x27;</span>,</span><br><span class="line">  height: <span class="number">1.2</span>,</span><br><span class="line">  run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is running...&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把xiaoming的原型指向了对象Student</span></span><br><span class="line">xiaoming.__proto__ = Student</span><br><span class="line">xiaoming.name <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">xiaoming.run() <span class="comment">// 小明 is running...</span></span><br></pre></td></tr></table></figure><p>JS 没有类的概念，所有对象都是实例，所谓继承关系就是把一个对象的原型指向另一个对象而已，如果你把 xiaoming 的原型指向其他对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Bird = &#123;</span><br><span class="line">  fly: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is flying...&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xiaoming.__proto__ = Bird</span><br><span class="line">xiaoming.fly() <span class="comment">// 小明 is flying...</span></span><br></pre></td></tr></table></figure><p>请注意，在 JS 中不要直接用 obj.<strong>proto</strong>去改变一个对象的原型，并且低版本的 IE 也无法使用<strong>proto</strong>。Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此我们可以编写一个函数来创建 xiaoming：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型对象:</span></span><br><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Robot&#x27;</span>,</span><br><span class="line">  height: <span class="number">1.2</span>,</span><br><span class="line">  run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is running...&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 基于Student原型创建一个新对象:</span></span><br><span class="line">  <span class="keyword">var</span> s = <span class="built_in">Object</span>.create(Student)</span><br><span class="line">  <span class="comment">// 初始化新对象:</span></span><br><span class="line">  s.name = name</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = createStudent(<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line">xiaoming.run() <span class="comment">// 小明 is running...</span></span><br><span class="line">xiaoming.__proto__ === Student <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h2><p>JS 可以用构造函数的方法来创建对象，它的用法是先定义一个构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在JS中用关键字new调用函数返回对象：</span></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line">xiaoming.name <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">xiaoming.hello() <span class="comment">// Hello, 小明!</span></span><br></pre></td></tr></table></figure><p>这里请注意，如果不写 new，这就是一个普通函数并返回 undefined。但是如果写了 new，它就变成了一个构造函数，它绑定的 this 指向新创建的对象并默认返回 this，也就是说不需要在最后 return this。用 new 创建的对象还从原型上获得了一个 constructor 属性，它指向函数 Student 本身：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xiaoming.constructor === Student.prototype.constructor <span class="comment">// true</span></span><br><span class="line">Student.prototype.constructor === Student <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(xiaoming) === Student.prototype <span class="comment">// true</span></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> Student <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Student.prototype 指向的对象就是 xiaoming、xiaohong 的原型对象，这个原型对象有个属性 constructor 指向 Student 函数本身，但是 xiaoming、xiaohong 这些对象没有 prototype 属性，不过可以用<strong>proto</strong>这个非标准用法来查看，现在我们就认为 xiaoming、xiaohong 这些对象“继承”自 Student。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xiaoming.name <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">xiaohong.name <span class="comment">// &#x27;小红&#x27;</span></span><br><span class="line">xiaoming.hello <span class="comment">// function: Student.hello()</span></span><br><span class="line">xiaohong.hello <span class="comment">// function: Student.hello()</span></span><br><span class="line">xiaoming.hello === xiaohong.hello <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>xiaoming 和 xiaohong 调用的 hello 是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的。要让创建的对象共享一个 hello 函数，根据对象的属性查找原则只要把函数移动到对象原型上就可以了，也就是 Student.prototype：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果创建对象时忘记写 new，在 strict 模式下，this.name = name 将报错，因为 this 绑定为 undefined，在非 strict 模式下，this.name = name 不报错，因为 this 绑定为 window，于是无意间创建了全局变量 name 并返回 undefined，这个结果更糟糕。为了区分普通函数和构造函数，按照规定构造函数首字母应当大写，而普通函数首字母小写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = props.name || <span class="string">&#x27;匿名&#x27;</span> <span class="comment">// 默认值为&#x27;匿名&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.grade = props.grade || <span class="number">1</span> <span class="comment">// 默认值为1</span></span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Student(props || &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = createStudent(&#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">xiaoming.grade <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>如果创建的对象有很多属性，我们只需要传递需要的某些属性，剩下的属性可以用默认值。</p><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>在传统的基于类和实例的语言中，继承的本质是类型的拓展，由于 JS 采用了原型继承，所以不存在类。我们想要在 JS 中实现继承可以借助于中间函数，用 inherits()函数进行封装还可以隐藏中间函数的定义，并简化代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = Parent.prototype</span><br><span class="line">  Child.prototype = <span class="keyword">new</span> F()</span><br><span class="line">  Child.prototype.constructor = Child</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = props.name || <span class="string">&#x27;Unnamed&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  Student.call(<span class="built_in">this</span>, props)</span><br><span class="line">  <span class="built_in">this</span>.grade = props.grade || <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现原型继承链:</span></span><br><span class="line">inherits(PrimaryStudent, Student)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定其他方法到PrimaryStudent原型:</span></span><br><span class="line">PrimaryStudent.prototype.getGrade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.grade</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JS 的原型继承实现方式如下：</p><ol><li>定义新的构造函数，并在内部用 call()调用希望“继承”的构造函数，并绑定 this；</li><li>借助中间函数实现原型链继承，最好通过封装的 inherits 函数完成；</li><li>继续在新的构造函数的原型上定义新方法；</li></ol><h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><p>我们知道 JS 的对象模型是基于原型实现的，特点是简单，但是实现继承需要大量代码。ES6 引入了新的关键字 class 来定义类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">hello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line">xiaoming.hello()</span><br></pre></td></tr></table></figure><p>用 class 直接通过 extends 来实现继承：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, grade</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name) <span class="comment">// 记得用super调用父类的构造方法!</span></span><br><span class="line">    <span class="built_in">this</span>.grade = grade</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">myGrade</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    alert(<span class="string">&#x27;I am at grade &#x27;</span> + <span class="built_in">this</span>.grade)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，因为不是所有的主流浏览器都支持 ES6 的 class，现在使用还不太方便，不过可以用 Babel 这个工具把 class 代码转换为传统的 prototype 代码。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2016/09/11/frontend/160911/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2016/09/11/frontend/160911/" class="post-title-link" itemprop="url">Javascript学习笔记-对象</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2016-09-11 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-11T00:00:00+08:00">2016-09-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 15:57:05" itemprop="dateModified" datetime="2020-11-18T15:57:05+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>8k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>7 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>在 JS 中用 <code>typeof</code> 操作符获取对象的类型，它总是返回一个字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span> <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.abs <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure><p>其中 number、string、boolean、function 和 undefined 是基本数据类型，我们注意到 null 的类型是 object，Array 的类型也是 object，如果我们用 typeof 将无法区分出 null、Array 和通常意义上的 object。除此以外，JS 还提供了包装对象，number、boolean 和 string 都有包装对象，包装对象用 new 创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) <span class="comment">// 123,生成了新的包装类型</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) <span class="comment">// true,生成了新的包装类型</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;str&#x27;</span>) <span class="comment">// &#x27;str&#x27;,生成了新的包装类型</span></span><br></pre></td></tr></table></figure><p>虽然包装对象看上去和原来一模一样，但他们的类型已经变为 object 了！所以包装对象和原始值用 <code>===</code> 比较会返回 false，一般情况下不要使用包装对象，尤其是 string 类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) === <span class="number">123</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) === <span class="literal">true</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;str&#x27;</span>) <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;str&#x27;</span>) === <span class="string">&#x27;str&#x27;</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>此外，Number()、Boolean 和 String()作为普通函数，把任何类型的数据转换为其相应类型（注意不是包装类型）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="built_in">Number</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// 123，相当于parseInt()或parseFloat()</span></span><br><span class="line"><span class="keyword">typeof</span> n <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Boolean</span>(<span class="string">&#x27;true&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> b <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b2 = <span class="built_in">Boolean</span>(<span class="string">&#x27;false&#x27;</span>) <span class="comment">// true! &#x27;false&#x27;字符串转换结果为true！因为它是非空字符串！</span></span><br><span class="line"><span class="keyword">var</span> b3 = <span class="built_in">Boolean</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">String</span>(<span class="number">123.45</span>) <span class="comment">// &#x27;123.45&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> s <span class="comment">// &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure><p>对 JS 中数据类型稍作总结如下：</p><ul><li>不要使用 new Number()、new Boolean()、new String()创建包装对象；</li><li>用 parseInt()或 parseFloat()来转换任意类型到 number；</li><li>用 String()来转换任意类型到 string，或者直接调用某个对象的 toString()方法；</li><li>通常不必把任意类型转换为 boolean 再判断，因为可以直接写 if (myVar) {…}；</li><li>typeof 操作符可以判断区分 number、boolean、string、function 和 undefined；</li><li>判断 Array 要使用 Array.isArray(arr)；</li><li>判断 null 请使用 myVar === null；</li><li>判断全局变量是否存在用 typeof window.myVar === ‘undefined’；</li><li>函数内部判断变量是否存在用 typeof myVar === ‘undefined’。</li></ul><p>最后需要指出 null 和 undefined 没有 toString()，number 对象调用 toString()要特殊处理一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123.</span>toString(); <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="number">123.</span>.toString(); <span class="comment">// &#x27;123&#x27;, 注意是两个点！</span></span><br><span class="line">(<span class="number">123</span>).toString(); <span class="comment">// &#x27;123&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>在 JS 中 Date 对象用来表示日期和时间：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">now <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">now.getFullYear() <span class="comment">// 2015, 年份</span></span><br><span class="line">now.getMonth() <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></span><br><span class="line">now.getDate() <span class="comment">// 24, 表示24号</span></span><br><span class="line">now.getDay() <span class="comment">// 3, 表示星期三</span></span><br><span class="line">now.getHours() <span class="comment">// 19, 24小时制</span></span><br><span class="line">now.getMinutes() <span class="comment">// 49, 分钟</span></span><br><span class="line">now.getSeconds() <span class="comment">// 22, 秒</span></span><br><span class="line">now.getMilliseconds() <span class="comment">// 875, 毫秒数</span></span><br><span class="line">now.getTime() <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br></pre></td></tr></table></figure><p>注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，如果要创建一个指定日期和时间的 Date 对象，可以用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">123</span>)</span><br><span class="line">d <span class="comment">// Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timestamp = <span class="built_in">Date</span>.parse(<span class="string">&#x27;2015-06-24T19:49:22.875+08:00&#x27;</span>)</span><br><span class="line"><span class="comment">// 这里返回一个时间戳，再转换为Date：</span></span><br><span class="line">timestamp <span class="comment">// 1435146562875</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(timestamp)</span><br><span class="line">date <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">date.toLocaleString() <span class="comment">// &#x27;2015/6/24 下午7:49:22&#x27;，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关</span></span><br><span class="line">date.toUTCString() <span class="comment">// &#x27;Wed, 24 Jun 2015 11:49:22 GMT&#x27;，UTC时间，与本地时间相差8小时</span></span><br></pre></td></tr></table></figure><p>需要强调的是 JS 中月份范围用整数表示是 0~11，从 0 开始。我们只需要从数据库读取时间戳，再转换为当地时间：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Date</span>.now) &#123;</span><br><span class="line">  alert(<span class="built_in">Date</span>.now()) <span class="comment">// 老版本IE没有now()方法</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><p>JS 中创建正则表达式有两种方式，第一种方式是直接通过/正则表达式/写出来，第二种方式是通过 new RegExp(‘正则表达式’)创建一个 RegExp 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ABC\-001/</span></span><br><span class="line"><span class="keyword">var</span> re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;ABC\\-001&#x27;</span>)</span><br><span class="line"></span><br><span class="line">re1 <span class="comment">// /ABC\-001/</span></span><br><span class="line">re2 <span class="comment">// /ABC\-001/</span></span><br></pre></td></tr></table></figure><p>RegExp 对象的 test()方法用于测试给定的字符串是否符合条件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^\d&#123;3&#125;\-\d&#123;3,8&#125;$/</span></span><br><span class="line">re.test(<span class="string">&#x27;010-12345&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">re.test(<span class="string">&#x27;010-1234x&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">re.test(<span class="string">&#x27;010 12345&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>用正则表达式切分字符串比用固定的字符更灵活：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;a b   c&#x27;</span>.split(<span class="string">&#x27; &#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="comment">// 用正则表达式切分</span></span><br><span class="line"><span class="string">&#x27;a b   c&#x27;</span>.split(<span class="regexp">/\s+/</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="comment">// 加入,试试</span></span><br><span class="line"><span class="string">&#x27;a,b, c  d&#x27;</span>.split(<span class="regexp">/[\s\,]+/</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure><p>一般用正则表达式把用户不规范的输入转化成正确的格式进行处理。除此之外，正则表达式还有提取子串的强大功能，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/</span></span><br><span class="line">re.exec(<span class="string">&#x27;010-12345&#x27;</span>) <span class="comment">// [&#x27;010-12345&#x27;, &#x27;010&#x27;, &#x27;12345&#x27;]</span></span><br><span class="line">re.exec(<span class="string">&#x27;010 12345&#x27;</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>exec()方法在匹配成功后，会返回一个 Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串；exec()方法在匹配失败时返回 null。<br>需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+)(0*)$/</span></span><br><span class="line">re.exec(<span class="string">&#x27;102300&#x27;</span>) <span class="comment">// [&#x27;102300&#x27;, &#x27;102300&#x27;, &#x27;&#x27;]</span></span><br></pre></td></tr></table></figure><p>由于\d+采用贪婪匹配，直接把后面的 0 全部匹配了，结果 0*只能匹配空字符串了。必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的 0 匹配出来，加个?就可以让\d+采用非贪婪匹配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+?)(0*)$/</span></span><br><span class="line">re.exec(<span class="string">&#x27;102300&#x27;</span>) <span class="comment">// [&#x27;102300&#x27;, &#x27;1023&#x27;, &#x27;00&#x27;]</span></span><br></pre></td></tr></table></figure><p>JS 的正则表达式还有几个特殊的标志，最常用的是 g 表示全局匹配，i 表示忽略大小写，m 表示执行多行匹配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/test/g</span></span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="keyword">var</span> r2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;g&#x27;</span>)</span><br></pre></td></tr></table></figure><p>全局匹配可以多次执行 exec()方法来搜索一个匹配的字符串，不能使用/^…$/，那样只会最多匹配一次。当我们指定 g 标志后，每次运行 exec()，正则表达式本身会更新 lastIndex 属性，表示上次匹配到的最后索引：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;JavaScript, VBScript, JScript and ECMAScript&#x27;</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/[a-zA-Z]+Script/g</span></span><br><span class="line"><span class="comment">// 使用全局匹配:</span></span><br><span class="line">re.exec(s) <span class="comment">// [&#x27;JavaScript&#x27;]</span></span><br><span class="line">re.lastIndex <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">re.exec(s) <span class="comment">// [&#x27;VBScript&#x27;]</span></span><br><span class="line">re.lastIndex <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">re.exec(s) <span class="comment">// [&#x27;JScript&#x27;]</span></span><br><span class="line">re.lastIndex <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line">re.exec(s) <span class="comment">// [&#x27;ECMAScript&#x27;]</span></span><br><span class="line">re.lastIndex <span class="comment">// 44</span></span><br><span class="line"></span><br><span class="line">re.exec(s) <span class="comment">// null，直到结束仍没有匹配到</span></span><br></pre></td></tr></table></figure><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON 实际上是 JavaScript 的一个子集，在 JS 中我们可以直接使用 JSON，因为 JavaScript 内置了 JSON 的解析。把任何 JavaScript 对象变成 JSON，就是把这个对象序列化成一个 JSON 格式的字符串，这样才能够通过网络传递给其他计算机。如果我们收到一个 JSON 格式的字符串，只需要把它反序列化成一个 JavaScript 对象，就可以在 JavaScript 中直接使用这个对象了。让我们先把小明这个对象序列化成 JSON 格式的字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">  age: <span class="number">14</span>,</span><br><span class="line">  gender: <span class="literal">true</span>,</span><br><span class="line">  height: <span class="number">1.65</span>,</span><br><span class="line">  grade: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;&quot;W3C&quot; Middle School&#x27;</span>,</span><br><span class="line">  skills: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Lisp&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming) <span class="comment">// &#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14,&quot;gender&quot;:true,&quot;height&quot;:1.65,&quot;grade&quot;:null,&quot;middle-school&quot;:&quot;\&quot;W3C\&quot; Middle School&quot;,&quot;skills&quot;:[&quot;JavaScript&quot;,&quot;Java&quot;,&quot;Python&quot;,&quot;Lisp&quot;]&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>可以加上参数按缩进输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, <span class="literal">null</span>, <span class="string">&#x27;  &#x27;</span>);</span><br><span class="line">结果：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="number">14</span>,</span><br><span class="line">  <span class="string">&quot;gender&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;height&quot;</span>: <span class="number">1.65</span>,</span><br><span class="line">  <span class="string">&quot;grade&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;middle-school&quot;</span>: <span class="string">&quot;\&quot;W3C\&quot; Middle School&quot;</span>,</span><br><span class="line">  <span class="string">&quot;skills&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;JavaScript&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Java&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Python&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Lisp&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入 Array：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;skills&#x27;</span>], <span class="string">&#x27;  &#x27;</span>);</span><br><span class="line">结果：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">  <span class="string">&quot;skills&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;JavaScript&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Java&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Python&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Lisp&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以传入一个函数，这样对象的每个键值对都会被函数先处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, convert, <span class="string">&#x27;  &#x27;</span>);</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="number">14</span>,</span><br><span class="line">  <span class="string">&quot;gender&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;height&quot;</span>: <span class="number">1.65</span>,</span><br><span class="line">  <span class="string">&quot;grade&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;middle-school&quot;</span>: <span class="string">&quot;\&quot;W3C\&quot; MIDDLE SCHOOL&quot;</span>,</span><br><span class="line">  <span class="string">&quot;skills&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;JAVASCRIPT&quot;</span>,</span><br><span class="line">    <span class="string">&quot;JAVA&quot;</span>,</span><br><span class="line">    <span class="string">&quot;PYTHON&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LISP&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们还想要精确控制如何序列化小明，可以给 xiaoming 定义一个 toJSON()的方法，直接返回 JSON 应该序列化的数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">  age: <span class="number">14</span>,</span><br><span class="line">  gender: <span class="literal">true</span>,</span><br><span class="line">  height: <span class="number">1.65</span>,</span><br><span class="line">  grade: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;&quot;W3C&quot; Middle School&#x27;</span>,</span><br><span class="line">  skills: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Lisp&#x27;</span>],</span><br><span class="line">  toJSON: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 只输出name和age，并且改变了key：</span></span><br><span class="line">      Name: <span class="built_in">this</span>.name,</span><br><span class="line">      Age: <span class="built_in">this</span>.age</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming) <span class="comment">// &#x27;&#123;&quot;Name&quot;:&quot;小明&quot;,&quot;Age&quot;:14&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>拿到一个 JSON 格式的字符串，我们直接用 JSON.parse()把它变成一个 JavaScript 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;[1,2,3,true]&#x27;</span>) <span class="comment">// [1, 2, 3, true]</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>) <span class="comment">// Object &#123;name: &#x27;小明&#x27;, age: 14&#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;true&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;123.45&#x27;</span>) <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure><p>JSON.parse()还可以接收一个函数，用来转换解析出的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 把number * 2:</span></span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="string">&#x27;同学&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;) <span class="comment">// Object &#123;name: &#x27;小明同学&#x27;, age: 14&#125;</span></span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2016/09/09/frontend/160909/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2016/09/09/frontend/160909/" class="post-title-link" itemprop="url">Javascript学习笔记-函数</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2016-09-09 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-09T00:00:00+08:00">2016-09-09</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 15:57:05" itemprop="dateModified" datetime="2020-11-18T15:57:05+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>9.6k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>9 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h2><p>JS 中定义函数的方式与其他语言一样没什么差别，但是要知道 JS 允许传入任意个数参数，如果传入的参数比定义的参数多也没有问题，函数内部并不会调用这些参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">abs(<span class="number">10</span>, <span class="string">&#x27;blablabla&#x27;</span>) <span class="comment">// 返回10</span></span><br><span class="line">abs(-<span class="number">9</span>, <span class="string">&#x27;haha&#x27;</span>, <span class="string">&#x27;hehe&#x27;</span>, <span class="literal">null</span>) <span class="comment">// 返回9</span></span><br></pre></td></tr></table></figure><p>传入的参数比定义的少也没有问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abs() <span class="comment">// 返回NaN</span></span><br></pre></td></tr></table></figure><p>JS 关键字 <code>argument</code> 在函数内部指向当前函数传入的所有参数，<code>arguments</code> 类似 Array 但它不是 Array：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  alert(x) <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    alert(<span class="built_in">arguments</span>[i]) <span class="comment">// 10, 20, 30</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>利用 <code>arguments</code> 可以获得调用者传入的所有参数，也就是说，即使函数不定义任何参数也可以拿到参数的值，而实际上 <code>arguments</code> 最常用于判断传入参数的个数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="built_in">arguments</span>[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">return</span> x &gt;= <span class="number">0</span> ? x : -x</span><br><span class="line">&#125;</span><br><span class="line">abs() <span class="comment">// 0</span></span><br><span class="line">abs(<span class="number">10</span>) <span class="comment">// 10</span></span><br><span class="line">abs(-<span class="number">9</span>) <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo(a[, b], c)</span></span><br><span class="line"><span class="comment">// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 实际拿到的参数是a和b，c为undefined</span></span><br><span class="line">    c = b <span class="comment">// 把b赋给c</span></span><br><span class="line">    b = <span class="literal">null</span> <span class="comment">// b变为默认值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要把中间的参数 <code>b</code> 变为“可选”参数，就只能通过 <code>arguments</code> 判断，然后重新调整参数并赋值。<br>为了获得额外的参数，ES6 标准引入了 <code>rest</code> 参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a = &#x27;</span> + a)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;b = &#x27;</span> + b)</span><br><span class="line">  <span class="built_in">console</span>.log(rest)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// Array [ 3, 4, 5 ]</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = undefined</span></span><br><span class="line"><span class="comment">// Array []</span></span><br></pre></td></tr></table></figure><p><code>rest</code> 参数写在最后，前面用 <code>...</code> 标识，多余的参数以数组形式交给变量 <code>rest</code>；如果传入的参数连正常定义的参数都没填满，<code>rest</code> 参数会接收一个空数组（注意不是 <code>undefined</code>）。</p><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>JS 的函数可以嵌套，内部函数可以访问外部函数定义的变量，如果内部函数和外部函数的变量名重名怎么办？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    alert(<span class="string">&#x27;x in bar() = &#x27;</span> + x) <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  alert(<span class="string">&#x27;x in foo() = &#x27;</span> + x) <span class="comment">// 1</span></span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这说明 JS 的函数在查找变量时从自身函数定义开始，由“内”向“外”查找，如果变量重名则内部变量将“屏蔽”外部变量。<br>JS 的函数在定义时会先扫描整个函数语句，把所有申明的变量“提升”到函数顶部：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">&#x27;Hello, &#x27;</span> + y</span><br><span class="line">  alert(x)</span><br><span class="line">  <span class="keyword">var</span> y = <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>虽然是 <code>strict</code> 模式，但语句 <code>var x = &#39;Hello, &#39; + y</code>;并不报错，原因是变量 <code>y</code> 在后面声明了。但虽然 JS 引擎自动提升了变量 <code>y</code> 的声明，却不会提升变量 y 的赋值，所以在赋值前 <code>y</code> 为 <code>undefined</code>。基于此我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则，最常见的做法是用一个 <code>var</code> 申明函数内部用到的所有变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        x = <span class="number">1</span>, <span class="comment">// x初始化为1</span></span><br><span class="line">        y = x + <span class="number">1</span>, <span class="comment">// y初始化为2</span></span><br><span class="line">        z, i; <span class="comment">// z和i为undefined</span></span><br><span class="line">    <span class="comment">// 其他语句:</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不在任何函数内定义的变量具有全局作用域，实际上 JS 默认有一个全局对象 <code>window</code><br>，全局作用域的变量实际上被作为的一个属性绑定到<code>window</code>。不同的 JS 文件如果使用了相同的全局变量或者定义了相同名字的函数，都会造成命名冲突，并且很难被发现。<br>减少冲突的一个方法是把所有变量和函数全部绑定到一个全局变量中例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唯一的全局变量MYAPP:</span></span><br><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;</span><br><span class="line"><span class="comment">// 其他变量:</span></span><br><span class="line">MYAPP.name = <span class="string">&#x27;myapp&#x27;</span></span><br><span class="line">MYAPP.version = <span class="number">1.0</span></span><br><span class="line"><span class="comment">// 其他函数:</span></span><br><span class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>许多著名的 JS 库都是这么做的如 Query，YUI，<code>underscore</code> 等等。此外，ES6 标准引入了新的关键字 <code>const</code> 和 <code>let</code>，用 <code>let</code> 替代 <code>var</code> 可以申明一个块级作用域的变量，而 <code>const</code><br>用来声明常量，<code>const</code> 与 <code>let</code> 都具有块级作用域。</p><h2 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h2><p>JS 的函数内部如果调用了 <code>this</code>，那么这个 <code>this</code> 到底指向谁？答案是视情况而定！如果以对象的方法形式调用，该函数的 <code>this</code> 指向被调用的对象；如果单独调用函数，此时该函数的 <code>this</code> 指向全局对象，也就是 <code>window</code>。因此 ECMA 决定，在 <code>strict</code> 模式下让函数的 <code>this</code> 指向 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">  birth: <span class="number">1990</span>,</span><br><span class="line">  age: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear()</span><br><span class="line">    <span class="keyword">return</span> y - <span class="built_in">this</span>.birth</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = xiaoming.age</span><br><span class="line">fn() <span class="comment">// Uncaught TypeError: Cannot read property &#x27;birth&#x27; of undefined</span></span><br></pre></td></tr></table></figure><p>这个决定只是让错误及时暴露出来，并没有解决 <code>this</code> 应该指向的正确位置，这时把方法重构了一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">  birth: <span class="number">1990</span>,</span><br><span class="line">  age: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear()</span><br><span class="line">      <span class="keyword">return</span> y - <span class="built_in">this</span>.birth</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getAgeFromBirth()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xiaoming.age() <span class="comment">// Uncaught TypeError: Cannot read property &#x27;birth&#x27; of undefined</span></span><br></pre></td></tr></table></figure><p>结果又报错了！原因是 <code>this</code> 指针只在 <code>age</code> 方法的函数内指向 <code>xiaoming</code>，在函数内部定义的函数，<code>this</code> 又指向 <code>undefined</code> 了（在非 <code>strict</code> 模式下，它重新指向全局对 <code>window</code>）！那么如何修改呢？我们用一个 <code>that</code> 变量替换 <code>this</code>，就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">  birth: <span class="number">1990</span>,</span><br><span class="line">  age: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span> <span class="comment">// 在方法内部一开始就捕获this</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear()</span><br><span class="line">      <span class="keyword">return</span> y - that.birth <span class="comment">// 用that而不是this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getAgeFromBirth()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xiaoming.age() <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><p>其实我们还是可以控制 <code>this</code> 指向哪个对象的，这里要用到函数本身的 <code>apply</code> 方法，它接收两个参数，第一个参数就是需要绑定的 <code>this</code> 变量，第二个参数是 Array，表示函数本身的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear()</span><br><span class="line">  <span class="keyword">return</span> y - <span class="built_in">this</span>.birth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">  birth: <span class="number">1990</span>,</span><br><span class="line">  age: getAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xiaoming.age() <span class="comment">// 25</span></span><br><span class="line">getAge.apply(xiaoming, []) <span class="comment">// 25, this指向xiaoming, 参数为空</span></span><br></pre></td></tr></table></figure><p>另一个与 <code>apply()</code> 类似的方法是 <code>call()</code>，唯一区别是：</p><ul><li><code>apply()</code> 把参数打包成 Array 再传入；</li><li><code>call()</code> 把参数按顺序传入。</li></ul><p>比如调用 <code>Math.max(3, 5, 4)</code>，分别用 <code>apply()</code> 和 <code>call()</code> 实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常把this绑定为null</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>利用 <code>apply()</code>，我们还可以动态改变函数的行为。因为 JS 的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span> <span class="comment">// 保存原函数</span></span><br><span class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count += <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>) <span class="comment">// 调用原函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试:</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>)</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;20&#x27;</span>)</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;30&#x27;</span>)</span><br><span class="line">count <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map()</code>接收一个函数并将函数作用在 Array 的每一个元素并把结果生成一个新的 Array。</p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p><code>reduce()</code> 是把一个函数作用在这个 Array 的[x1, x2, x3…]上，这个函数必须接收两个参数，<code>reduce()</code> 把结果继续和序列的下一个元素做累积计算，其效果就是：<br><code>[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</code><br>比方说对一个 Array 求和，就可以用 <code>reduce()</code> 实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;) <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter()</code> 用于把 Array 的某些元素过滤掉，然后返回剩下的元素。和 <code>map()</code> 类似，<code>filter()</code> 也接收一个函数，但不同的是 <code>filter()</code> 把传入的函数依次作用于每个元素，然后根据返回值是 <code>true</code> 还是 <code>false</code> 决定保留还是丢弃该元素。例如，在一个 Array 中，删掉偶数只保留奇数，可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>]</span><br><span class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line">r <span class="comment">// [1, 5, 9, 15]</span></span><br></pre></td></tr></table></figure><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>Array 的 <code>sort()</code> 方法默认把所有元素先转换为 String 再排序，而字符串根据 ASCII 码进行排序。同时 <code>sort()</code> 方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序，要按数字大小排序，我们可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正序</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;) <span class="comment">// [1, 2, 10, 20]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 倒序</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;) <span class="comment">// [20, 10, 2, 1]</span></span><br></pre></td></tr></table></figure><p><code>sort()</code> 方法会直接对 Array 进行修改，它返回的结果仍是当前 Array。</p><h2 id="闭包函数"><a href="#闭包函数" class="headerlink" title="闭包函数"></a>闭包函数</h2><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为返回值。注意到返回的函数在其内部引用了局部变量，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以闭包实现起来可不容易。另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用时才执行。我们来看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">    arr.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i * i</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> results = count()</span><br><span class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">var</span> f2 = results[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">var</span> f3 = results[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>在上面的例子中，每次循环都创建了一个新的函数，然后把创建的函数都添加到 Array 中返回。返回的函数引用了变量 <code>i</code>，但它并非立刻执行，函数都返回时所引用的变量 <code>i</code> 已经变成了 4，因此最终结果为 16。所以返回闭包时牢记：返回函数不要引用任何循环变量或者后续会发生变化的变量，也可以创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">    arr.push(</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> n * n</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)(i)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results = count()</span><br><span class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">var</span> f2 = results[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">var</span> f3 = results[<span class="number">2</span>]</span><br><span class="line">f1() <span class="comment">// 1</span></span><br><span class="line">f2() <span class="comment">// 4</span></span><br><span class="line">f3() <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p>JS 中，创建一个匿名函数并立刻执行可以这么写：<br><code>(function (x) &#123; return x * x &#125;) (3);</code></p><p>在没有 <code>class</code> 机制，只有函数的语言里，借助闭包可以封装一个私有变量。我们用 JS 创建一个计数器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_counter</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = initial || <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    inc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      x += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c1 = create_counter()</span><br><span class="line">c1.inc() <span class="comment">// 1</span></span><br><span class="line">c1.inc() <span class="comment">// 2</span></span><br><span class="line">c1.inc() <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> c2 = create_counter(<span class="number">10</span>)</span><br><span class="line">c2.inc() <span class="comment">// 11</span></span><br><span class="line">c2.inc() <span class="comment">// 12</span></span><br><span class="line">c2.inc() <span class="comment">// 13</span></span><br></pre></td></tr></table></figure><p>在返回的对象中实现了一个闭包，该闭包携带了局部变量 <code>x</code>，并且从外部根本无法访问到变量 <code>x</code>。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起<br>来。闭包还可以把多参数的函数变成单参数的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make_pow</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建两个新函数:</span></span><br><span class="line"><span class="keyword">var</span> pow2 = make_pow(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> pow3 = make_pow(<span class="number">3</span>)</span><br><span class="line">pow2(<span class="number">5</span>) <span class="comment">// 25</span></span><br><span class="line">pow3(<span class="number">7</span>) <span class="comment">// 343</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数相当于匿名函数，并且简化了函数定义。它有两种格式，一种只包含一个表达式，连{ … }和 <code>return</code> 都省略掉了；还有一种可以包含多条语句，这时候就不能省略{ … }和 return：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> - x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个参数:</span></span><br><span class="line">(x, y) =&gt; x * x + y * y</span><br><span class="line"><span class="comment">// 无参数:</span></span><br><span class="line">() =&gt; <span class="number">3.14</span></span><br><span class="line"><span class="comment">// 可变参数:</span></span><br><span class="line">(x, y, ...rest) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> i, sum = x + y;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rest.length; i++) &#123;</span><br><span class="line">        sum += rest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要返回一个对象，因为和函数体的 <code>&#123; ... &#125;</code> 有语法冲突，要这么写：<code>x =&gt; (&#123; foo: x &#125;)</code><br>箭头函数内部的 <code>this</code> 是词法作用域，总是指向外层调用者，由上下文确定：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  birth: <span class="number">1990</span>,</span><br><span class="line">  getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">this</span>.birth <span class="comment">// 1990</span></span><br><span class="line">    <span class="keyword">var</span> fn = <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="built_in">this</span>.birth <span class="comment">// this指向obj对象</span></span><br><span class="line">    <span class="keyword">return</span> fn()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getAge() <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><p>由于 <code>this</code> 在箭头函数中已经按照词法作用域绑定了，所以用 <code>call()</code> 或者 <code>apply()</code> 调用箭头函数时，无法对 <code>this</code> 进行绑定，即传入的第一个参数被忽略：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  birth: <span class="number">1990</span>,</span><br><span class="line">  getAge: <span class="function"><span class="keyword">function</span>(<span class="params">year</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">this</span>.birth <span class="comment">// 1990</span></span><br><span class="line">    <span class="keyword">var</span> fn = <span class="function"><span class="params">y</span> =&gt;</span> y - <span class="built_in">this</span>.birth <span class="comment">// this.birth仍是1990</span></span><br><span class="line">    <span class="keyword">return</span> fn.call(&#123; <span class="attr">birth</span>: <span class="number">2000</span> &#125;, year)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getAge(<span class="number">2015</span>) <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p><code>generator</code> 是 ES6 标准引入的新的数据类型，一个 <code>generator</code> 看上去像一个函数，但可以返回多次。<code>generator</code> 定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> x + <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> x + <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>generator</code> 和函数不同的是，<code>generator</code> 由 <code>function*</code> 定义（注意多出的 <code>*</code> 号），并且，除了 <code>return</code> 语句，还可以用 <code>yield</code> 返回多次。要编写一个产生斐波那契数列的函数，可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> t,</span><br><span class="line">    a = <span class="number">0</span>,</span><br><span class="line">    b = <span class="number">1</span>,</span><br><span class="line">    arr = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">while</span> (arr.length &lt; max) &#123;</span><br><span class="line">    t = a + b</span><br><span class="line">    a = b</span><br><span class="line">    b = t</span><br><span class="line">    arr.push(t)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试:</span></span><br><span class="line">fib(<span class="number">5</span>) <span class="comment">// [0, 1, 1, 2, 3]</span></span><br><span class="line">fib(<span class="number">10</span>) <span class="comment">// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br></pre></td></tr></table></figure><p>函数只能返回一次，但是如果换成 <code>generator</code>，就可以一次返回一个数，不断返回多次：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fib</span>(<span class="params">max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> t,</span><br><span class="line">    a = <span class="number">0</span>,</span><br><span class="line">    b = <span class="number">1</span>,</span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (n &lt; max) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a</span><br><span class="line">    t = a + b</span><br><span class="line">    a = b</span><br><span class="line">    b = t</span><br><span class="line">    n++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line">fib(<span class="number">5</span>) <span class="comment">// fib &#123;[[GeneratorStatus]]: &quot;suspended&quot;, [[GeneratorReceiver]]: Window&#125;</span></span><br></pre></td></tr></table></figure><p>调用 <code>generator</code> 和调用函数不一样，<code>fib(5)</code> 仅仅是创建了一个 <code>generator</code> 对象，还没有去执行它。调用 <code>generator</code> 对象有两个方法：<br>一是不断地调用 <code>generator</code> 对象的 <code>next()</code>方法；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = fib(<span class="number">5</span>)</span><br><span class="line">f.next() <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line">f.next() <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.next() <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.next() <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next() <span class="comment">// &#123;value: 3, done: true&#125;</span></span><br></pre></td></tr></table></figure><p><code>next()</code> 方法会执行 <code>generator</code> 的代码，每次遇到 <code>yield</code> 就返回一个对象 <code>&#123;value: x, done: true/false&#125;</code> 并“暂停”，返回的 <code>value</code> 就是 <code>yield</code> 的返回值，<code>done</code> 表示这个 <code>generator</code> 是否已经执行结束了。<br>二是直接用 <code>for ... of</code> 循环迭代 <code>generator</code> 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> fib(<span class="number">5</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 依次输出0, 1, 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>generator</code> 在执行过程中多次返回，所以它可以记住执行状态。<code>generator</code> 还有另一个巨大的好处，就是把异步回调变成“同步”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">&#x27;http://url-1&#x27;</span>, data1, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> handle(err);</span><br><span class="line">    &#125;</span><br><span class="line">    ajax(<span class="string">&#x27;http://url-2&#x27;</span>, data2, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">return</span> handle(err);</span><br><span class="line">        &#125;</span><br><span class="line">        ajax(<span class="string">&#x27;http://url-3&#x27;</span>, data3, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="keyword">return</span> handle(err);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> success(result);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    r1 = <span class="keyword">yield</span> ajax(<span class="string">&#x27;http://url-1&#x27;</span>, data1);</span><br><span class="line">    r2 = <span class="keyword">yield</span> ajax(<span class="string">&#x27;http://url-2&#x27;</span>, data2);</span><br><span class="line">    r3 = <span class="keyword">yield</span> ajax(<span class="string">&#x27;http://url-3&#x27;</span>, data3);</span><br><span class="line">    success(r3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    handle(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去是同步的代码，实际上是异步执行。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2016/09/07/frontend/160907/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2016/09/07/frontend/160907/" class="post-title-link" itemprop="url">Javascript学习笔记-数据类型</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2016-09-07 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-07T00:00:00+08:00">2016-09-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 15:57:05" itemprop="dateModified" datetime="2020-11-18T15:57:05+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>8k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>7 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>1995 年，网景公司凭借 Navigator 浏览器成为当时最著名的互联网公司，为了能在静态 HTML 页面上添加一些动态效果，Brendan Eich 在两周内设计写出了 JavaScript 语言，相信很多人刚开始都会纠结于 Javascript 和 Java 有什么关系，其实就是网景公司想借助于当时非常火爆的 Java 来推广自己。随着 JavaScript 的发展，ECMA（European Computer Manufacturers Association）指定了 JavaScript 语言的标准，被称为 ECMAScript 标准，最新版 ECMAScript 6 标准（简称 ES6）已经在 2015 年 6 月正式发布了。</p><h2 id="特殊语法"><a href="#特殊语法" class="headerlink" title="特殊语法"></a>特殊语法</h2><p>在 JS 中定义了以下几种数据类型：Number、String、Bool，其中需要注意的是</p><ul><li>NaN // NaN 表示 Not a Number，当无法计算结果时用 NaN 表示；</li><li>Infinity // Infinity 表示无限大，当数值超过了 JavaScript 的最大值时使用 Infinity；</li></ul><p>JS 中对数据类型做比较时要特别注意比较运算符 <code>==</code>，JS 设计时有两种比较运算符</p><ul><li><code>==</code> 会自动转换数据类型再比较，很多时候会得到非常诡异的结果；</li><li><code>===</code> 不会自动转换数据类型，如果数据类型不一致则返回 <code>false</code>，如果一致再比较。<br>基于 JS 这个设计缺陷，不要使用 <code>==</code>，请始终坚持使用 <code>===</code>。</li></ul><p>另一个例外是 NaN 这个特殊的 Number 与所有其他值都不相等包括它自己：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>唯一能判断 NaN 的方法是通过 isNaN()函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>null/undefined</strong></p><p><code>null</code> 表示一个空值，而 <code>undefined</code> 表示值未定义；大多数情况下都使用 <code>null</code>，<code>undefined</code> 仅在判断函数参数是否传递的情况下才用。</p><p>JS 是一种动态语言，可以把任意数据类型反复赋值给同一个变量，与之对应的静态语言在定义变量时必须指定变量类型。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>ASCII 字符可以以 <code>\x##</code> 形式的十六进制表示如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;\x41&#x27;</span> <span class="comment">// 完全等同于 &#x27;A&#x27;</span></span><br></pre></td></tr></table></figure><p>还可以用\u####表示 Unicode 字符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;\u4e2d\u6587&#x27;</span> <span class="comment">// 完全等同于 &#x27;中文&#x27;</span></span><br></pre></td></tr></table></figure><p>ES6 新增了一种模板字符串会自动替换字符串中的变量如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`你好, <span class="subst">$&#123;name&#125;</span>, 你今年<span class="subst">$&#123;age&#125;</span>岁了!`</span></span><br><span class="line">alert(message)</span><br></pre></td></tr></table></figure><p>需要注意的是字符串不可变，如果对字符串的某个索引赋值不会报错，但也没有任何效果。<br>JS 为字符串提供了一些常用方法，这里请注意这些方法不会改变原有字符串，而是返回一个新的字符串：<code>toUpperCase()</code> 把一个字符串全部变为大写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">s.toUpperCase() <span class="comment">// 返回&#x27;HELLO&#x27;</span></span><br></pre></td></tr></table></figure><p><code>toLowerCase()</code> 把一个字符串全部变为小写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="keyword">var</span> lower = s.toLowerCase() <span class="comment">// 返回&#x27;hello&#x27;并赋值给变量lower</span></span><br><span class="line">lower <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><p><code>indexOf()</code> 会搜索指定字符串出现的位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">s.indexOf(<span class="string">&#x27;world&#x27;</span>) <span class="comment">// 返回7</span></span><br><span class="line">s.indexOf(<span class="string">&#x27;World&#x27;</span>) <span class="comment">// 没有找到指定的子串，返回-1</span></span><br></pre></td></tr></table></figure><p><code>substring()</code> 返回指定索引区间的子串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">s.substring(<span class="number">0</span>, <span class="number">5</span>) <span class="comment">// 从索引0开始到5（不包括5），返回&#x27;hello&#x27;</span></span><br><span class="line">s.substring(<span class="number">7</span>) <span class="comment">// 从索引7开始到结束，返回&#x27;world&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>JS 中直接给 Array 的 <code>length</code> 赋值会改变 Array 大小：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.length <span class="comment">// 3</span></span><br><span class="line">arr.length = <span class="number">6</span></span><br><span class="line">arr <span class="comment">// arr变为[1, 2, 3, undefined, undefined, undefined]</span></span><br><span class="line">arr.length = <span class="number">2</span></span><br><span class="line">arr <span class="comment">// arr变为[1, 2]</span></span><br></pre></td></tr></table></figure><p>如果通过索引赋值时索引超过了 Array 范围，同样会改变 Array 大小：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">&#x27;x&#x27;</span></span><br><span class="line">arr <span class="comment">// arr变为[1, 2, 3, undefined, undefined, &#x27;x&#x27;]</span></span><br></pre></td></tr></table></figure><p>大多数编程语言不允许直接改变数组大小，越界访问索引会报错，然而 JS 的 Array 却不会报错。在编写代码时不建议直接修改 Array 大小，访问索引时要确保索引不会越界。</p><p>与 String 类似，Array 也可以通过 <code>indexOf()</code> 来搜索一个指定的元素的位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="string">&#x27;30&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>];</span><br><span class="line">arr.indexOf(<span class="number">10</span>); <span class="comment">// 元素10的索引为0</span></span><br><span class="line">arr.indexOf(<span class="number">20</span>); <span class="comment">// 元素20的索引为1</span></span><br><span class="line">arr.indexOf(<span class="number">30</span>); <span class="comment">// 元素30没有找到，返回-1</span></span><br><span class="line">arr.indexOf(<span class="string">&#x27;30&#x27;</span>); <span class="comment">// 元素&#x27;30&#x27;的索引为2</span></span><br><span class="line">注意了，数字<span class="number">30</span>和字符串<span class="string">&#x27;30&#x27;</span>是不同的元素。</span><br></pre></td></tr></table></figure><p><code>slice()</code> 截取 Array 的部分元素，然后返回一个新的 Array：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>];</span><br><span class="line">arr.slice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 从索引0开始，到索引3结束，但不包括索引3: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">arr.slice(<span class="number">3</span>); <span class="comment">// 从索引3开始到结束: [&#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br><span class="line">注意到slice()的起止参数包括开始索引，不包括结束索引。</span><br></pre></td></tr></table></figure><p>如果不给 <code>slice()</code> 传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个 Array：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> aCopy = arr.slice()</span><br><span class="line">aCopy <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br><span class="line">aCopy === arr <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>push()</code> 向 Array 的末尾添加元素，<code>pop()</code> 则删掉 Array 的最后一个元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">arr.push(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>) <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr <span class="comment">// [1, 2, &#x27;A&#x27;, &#x27;B&#x27;]</span></span><br><span class="line">arr.pop() <span class="comment">// pop()返回&#x27;B&#x27;</span></span><br><span class="line">arr <span class="comment">// [1, 2, &#x27;A&#x27;]</span></span><br><span class="line">arr.pop()</span><br><span class="line">arr.pop()</span><br><span class="line">arr.pop() <span class="comment">// 连续pop 3次</span></span><br><span class="line">arr <span class="comment">// []</span></span><br><span class="line">arr.pop() <span class="comment">// 空数组继续pop不会报错，而是返回undefined</span></span><br><span class="line">arr <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p><code>unshift()</code> 向 Array 的开头添加元素，<code>shift()</code> 则删掉 Array 的第一个元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">arr.unshift(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>) <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, 1, 2]</span></span><br><span class="line">arr.shift() <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line">arr <span class="comment">// [&#x27;B&#x27;, 1, 2]</span></span><br><span class="line">arr.shift()</span><br><span class="line">arr.shift()</span><br><span class="line">arr.shift() <span class="comment">// 连续shift 3次</span></span><br><span class="line">arr <span class="comment">// []</span></span><br><span class="line">arr.shift() <span class="comment">// 空数组继续shift不会报错，而是返回undefined</span></span><br><span class="line">arr <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p><code>sort()</code> 可以对当前 Array 进行排序，它会直接修改当前 Array 的元素位置，直接调用时按照默认顺序排序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">arr.sort()</span><br><span class="line">arr <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>reverse()</code> 把整个 Array 的元素顺序颠倒过来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line">arr.reverse()</span><br><span class="line">arr <span class="comment">// [&#x27;three&#x27;, &#x27;two&#x27;, &#x27;one&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>splice()</code> 可以从指定的索引位置删除若干元素，然后再从该位置添加若干元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Yahoo&#x27;</span>, <span class="string">&#x27;AOL&#x27;</span>, <span class="string">&#x27;Excite&#x27;</span>, <span class="string">&#x27;Oracle&#x27;</span>]</span><br><span class="line"><span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>) <span class="comment">// 返回删除的元素 [&#x27;Yahoo&#x27;, &#x27;AOL&#x27;, &#x27;Excite&#x27;]</span></span><br><span class="line">arr <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"><span class="comment">// 只删除,不添加:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">2</span>) <span class="comment">// [&#x27;Google&#x27;, &#x27;Facebook&#x27;]</span></span><br><span class="line">arr <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"><span class="comment">// 只添加,不删除:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>) <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>concat()</code> 连接当前 Array 和另一个 Array，返回一个新的 Array：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> added = arr.concat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">added <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3]</span></span><br><span class="line">arr <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure><p>实际上，<code>concat()</code> 方法可以接收任意个元素和 Array，并且自动添加到新的 Array 里：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">arr.concat(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]) <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p><code>join()</code> 方法用指定的字符把当前 Array 的每个元素连接起来，返回连接得到的字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.join(<span class="string">&#x27;-&#x27;</span>) <span class="comment">// &#x27;A-B-C-1-2-3&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>JS 中通过点语法访问对象属性，但如果属性名包含特殊字符，就必须用 <code>&#39;&#39;</code> 括起来，<br>访问这个属性也无法使用点语法，必须通过 <code>[&#39;xxx&#39;]</code> 这种形式访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaohong = &#123;</span><br><span class="line">  name: <span class="string">&#x27;小红&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;No.1 Middle School&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">xiaohong[<span class="string">&#x27;middle-school&#x27;</span>] <span class="comment">// &#x27;No.1 Middle School&#x27;</span></span><br><span class="line">xiaohong[<span class="string">&#x27;name&#x27;</span>] <span class="comment">// &#x27;小红&#x27;</span></span><br><span class="line">xiaohong.name <span class="comment">// &#x27;小红&#x27;</span></span><br></pre></td></tr></table></figure><p>所以我们在写 JS 代码时，属性名尽量使用标准写法，这样就可以直接通过点语法访问属性了。<br>JS 中访问不存在的属性不会报错，而是返回 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">xiaoming.age <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>由于 JS 对象是动态类型，你可以自由地给一个对象添加或删除属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">xiaoming.age <span class="comment">// undefined</span></span><br><span class="line">xiaoming.age = <span class="number">18</span> <span class="comment">// 新增一个age属性</span></span><br><span class="line">xiaoming.age <span class="comment">// 18</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.age <span class="comment">// 删除age属性</span></span><br><span class="line">xiaoming.age <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming[<span class="string">&#x27;name&#x27;</span>] <span class="comment">// 删除name属性</span></span><br><span class="line">xiaoming.name <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.school <span class="comment">// 删除一个不存在的school属性也不会报错</span></span><br></pre></td></tr></table></figure><p>如果我们要检测 <code>xiaoming</code> 是否拥有某一属性，可以用 <code>in</code> 操作符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">  birth: <span class="number">1990</span>,</span><br><span class="line">  school: <span class="string">&#x27;No.1 Middle School&#x27;</span>,</span><br><span class="line">  height: <span class="number">1.7</span>,</span><br><span class="line">  weight: <span class="number">65</span>,</span><br><span class="line">  score: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> xiaoming <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;grade&#x27;</span> <span class="keyword">in</span> xiaoming <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>不过要小心，如果 <code>in</code> 判断一个属性存在，这个属性也可能是 <code>xiaoming</code> 继承得到的,要判断一个属性是否为 <code>xiaoming</code> 自身拥有，可以用 <code>hasOwnProperty()</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="Map-Set"><a href="#Map-Set" class="headerlink" title="Map/Set"></a>Map/Set</h2><p>Map 同字典一样都是键值对结构，具有极快的查找速度，JS 中 Map 写法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;Michael&#x27;</span>, <span class="number">95</span>], [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">75</span>], [<span class="string">&#x27;Tracy&#x27;</span>, <span class="number">85</span>]])</span><br><span class="line">m.get(<span class="string">&#x27;Michael&#x27;</span>) <span class="comment">// 95</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>() <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">67</span>) <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">59</span>)</span><br><span class="line">m.has(<span class="string">&#x27;Adam&#x27;</span>) <span class="comment">// 是否存在key &#x27;Adam&#x27;: true</span></span><br><span class="line">m.get(<span class="string">&#x27;Adam&#x27;</span>) <span class="comment">// 67</span></span><br><span class="line">m.delete(<span class="string">&#x27;Adam&#x27;</span>) <span class="comment">// 删除key &#x27;Adam&#x27;</span></span><br><span class="line">m.get(<span class="string">&#x27;Adam&#x27;</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>Set 就是无序集合：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>() <span class="comment">// 空Set</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 含1, 2, 3</span></span><br><span class="line"><span class="comment">// 重复元素在Set中自动被过滤：</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">&#x27;3&#x27;</span>])</span><br><span class="line">s <span class="comment">// Set &#123;1, 2, 3, &quot;3&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>通过 <code>add(key)</code> 方法可以添加元素到 Set 中，但重复添加不会有效果，通过 <code>delete(key)</code> 方法可以删除元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">s <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line">s.delete(<span class="number">3</span>)</span><br><span class="line">s <span class="comment">// Set &#123;1, 2&#125;</span></span><br></pre></td></tr></table></figure><p>为了统一集合类型，ES6 标准引入了新的 <code>iterable</code> 类型，Array、Map 和 Set 都属于 <code>iterable</code> 类型，具有 <code>iterable</code> 类型的集合可以通过新的 <code>for ... of</code> 循环来遍历。<br>然而最好直接使用 <code>iterable</code> 内置的 <code>forEach</code> 方法，<code>forEach()</code> 方法是 ES5.1 标准引入的，它接收一个函数，每次迭代就自动回调该函数。以 Array 为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// element: 指向当前元素的值</span></span><br><span class="line">  <span class="comment">// index: 指向当前索引</span></span><br><span class="line">  <span class="comment">// array: 指向Array对象本身</span></span><br><span class="line">  alert(element)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Map 的回调函数参数依次为 <code>value</code>、<code>key</code> 和 <code>map</code> 本身：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;z&#x27;</span>]])</span><br><span class="line">m.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">  alert(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>JS 的函数调用不要求参数必须一致，因此可以忽略它们：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  alert(element)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Strict-模式"><a href="#Strict-模式" class="headerlink" title="Strict 模式"></a>Strict 模式</h2><p>JS 在设计之初并不强制要求用 <code>var</code> 申明变量，这个设计错误带来了严重的后果：如果一个变量没有通过 <code>var</code> 申明就被使用，那么该变量就自动变为全局变量；在同一页面的不同 JS 文件中，如果都不用 <code>var</code> 申明相同的变量，将造成变量相互影响产生难以调试的错误结果。<br>为了修补 JS 这一严重缺陷，ECMA 推出了 <code>strict</code> 模式，在 <code>strict</code> 模式下运行的 JS 代码强制通过 <code>var</code> 申明变量，未使用 <code>var</code> 申明的变量在使用时会报错，启用 <code>strict</code> 模式的方法是在 JS 代码的第一行写上 <code>use strict</code>。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2016/09/02/frontend/160902/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2016/09/02/frontend/160902/" class="post-title-link" itemprop="url">网页图片预加载</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2016-09-02 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-02T00:00:00+08:00">2016-09-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 15:57:31" itemprop="dateModified" datetime="2020-11-18T15:57:31+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>5k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>正常情况下，网页加载图片会从上到下像”瀑布”一样加载出来，而预加载就是等所有图片加载完毕后一次性将图片显示出来，提高了页面加载速度与用户体验。</p><p>如果页面使用了在用户交互后才显示的图片，有必要进行预加载：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.preloadImages = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    $(<span class="string">&#x27;img&#x27;</span>).attr(<span class="string">&#x27;src&#x27;</span>, <span class="built_in">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">$.preloadImages(<span class="string">&#x27;img/hover-on.png&#x27;</span>, <span class="string">&#x27;img/hover-off.png&#x27;</span>);</span><br></pre></td></tr></table></figure><p>当页面加载大量图片时经常会出现白页，我们可以提高服务器性能，使用静态缓存等手段来加快图片加载速度；下面介绍一种在实际应用中经常用到的 <code>js</code> 预加载方法：在图片标签处做处理 <code>&lt;image data=&quot;图片实际地址&quot; src=&quot;占位图&quot; alt=&quot;图片名&quot; /&gt;</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;img[data]&#x27;</span>).load(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __this__ = $(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">var</span> url = __this__.attr(<span class="string">&#x27;data&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> src = __this__.attr(<span class="string">&#x27;src&#x27;</span>);</span><br><span class="line">  <span class="comment">// 如果图片地址不存在或者已经加载,不做处理</span></span><br><span class="line">  <span class="keyword">if</span> (url == <span class="string">&#x27;&#x27;</span> || url == src) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> img = newImage();</span><br><span class="line">  <span class="comment">// 加载将要显示的图片</span></span><br><span class="line">  img.src = url;</span><br><span class="line">  <span class="comment">// 如果图片已经加载到缓存,直接处理</span></span><br><span class="line">  <span class="keyword">if</span> (img.complete) &#123;</span><br><span class="line">    <span class="comment">// 替换将要显示的图片</span></span><br><span class="line">    __this__.attr(<span class="string">&#x27;src&#x27;</span>, url);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 图片加载完成再做处理</span></span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    __this__.attr(<span class="string">&#x27;src&#x27;</span>, url);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果需要在页面初始加载时显示加载进度，在图片很多的情况下可以使用第三方插件 <code>jquery.imgpreload.min.js</code> 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在全局范围内改变或重写默认设置的imgpreload方法</span></span><br><span class="line">$.fn.imgpreload.defaults = &#123;</span><br><span class="line">  each: <span class="literal">null</span>, <span class="comment">// callback invoked when each image is loaded</span></span><br><span class="line">  all: <span class="literal">null</span>, <span class="comment">// callback invoked when all images have loaded</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在标签加载完成后预加载图片</span></span><br><span class="line">$(<span class="string">&#x27;#content img&#x27;</span>).imgpreload(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// callback invoked when all images have loaded</span></span><br><span class="line">  <span class="comment">// this = array of dom image objects</span></span><br><span class="line">  <span class="comment">// check for success with: $(this[i]).data(&#x27;loaded&#x27;)</span></span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&#x27;img.logos&#x27;</span>).imgpreload(&#123;</span><br><span class="line">  each: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// callback invoked when each image is loaded</span></span><br><span class="line">    <span class="comment">// this = dom image object</span></span><br><span class="line">    <span class="comment">// check for success with: $(this).data(&#x27;loaded&#x27;)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  all: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// callback invoked when all images have loaded</span></span><br><span class="line">    <span class="comment">// this = array of dom image objects</span></span><br><span class="line">    <span class="comment">// check for success with: $(this[i]).data(&#x27;loaded&#x27;)</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 在标签加载前预加载图片,在文档头部必须使用特定路径</span></span><br><span class="line">$.imgpreload(<span class="string">&#x27;/images/a.gif&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// callback invoked when all images have loaded</span></span><br><span class="line">  <span class="comment">// this = array of dom image objects</span></span><br><span class="line">  <span class="comment">// check for success with: $(this[i]).data(&#x27;loaded&#x27;)</span></span><br><span class="line">&#125;);</span><br><span class="line">$.imgpreload([<span class="string">&#x27;/images/a.gif&#x27;</span>, <span class="string">&#x27;/images/b.gif&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this = array of dom image objects</span></span><br><span class="line">  <span class="comment">// check for success with: $(this[i]).data(&#x27;loaded&#x27;)</span></span><br><span class="line">  <span class="comment">// callback executes when all images are loaded</span></span><br><span class="line">&#125;);</span><br><span class="line">$.imgpreload([<span class="string">&#x27;/images/a.gif&#x27;</span>, <span class="string">&#x27;/images/b.gif&#x27;</span>], &#123;</span><br><span class="line">  each: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// callback invoked when each image is loaded</span></span><br><span class="line">    <span class="comment">// this = dom image object</span></span><br><span class="line">    <span class="comment">// check for success with: $(this).data(&#x27;loaded&#x27;)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  all: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// callback invoked when all images have loaded</span></span><br><span class="line">    <span class="comment">// this = array of dom image objects</span></span><br><span class="line">    <span class="comment">// check for success with: $(this[i]).data(&#x27;loaded&#x27;)</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>jquery.imgpreload</code> 的实际使用有两种方式如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> imgNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> images = [];</span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  preloadImg();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preLoadImg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 第一种方式:获取页面中所有img,包括&lt;img&gt;标签和css中的background-image;</span></span><br><span class="line">  <span class="keyword">var</span> imgs = <span class="built_in">document</span>.images;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imgs.length; i++) &#123;</span><br><span class="line">    images.push(imgs[i].src);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> cssImages = getallBgimages();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; cssImages.length; j++) &#123;</span><br><span class="line">    images.push(cssImages[j]);</span><br><span class="line">  &#125;*/</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二种方式:把所有网页图片文件预先放入一个数组里;</span></span><br><span class="line">  $.imgpreload([<span class="string">&#x27;images/bg1.jpg&#x27;</span>, <span class="string">&#x27;images/bg2.jpg&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//此处是显示进度百分比时需要用到的背景图，这个可以先加载进去</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//then push all other images in array to load</span></span><br><span class="line">  images.push(<span class="string">&quot;images/test_1.png&quot;</span>);</span><br><span class="line">  images.push(<span class="string">&quot;images/test_2.png&quot;</span>);</span><br><span class="line">  images.push(<span class="string">&quot;images/test_3.png&quot;</span>);</span><br><span class="line">  images.push(<span class="string">&quot;images/test_n.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">  $.imgpreload(images, &#123;</span><br><span class="line">    each: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*this will be called after each image loaded*/</span></span><br><span class="line">    <span class="keyword">var</span> status = $(<span class="built_in">this</span>).data(<span class="string">&#x27;loaded&#x27;</span>) ? <span class="string">&#x27;success&#x27;</span> : <span class="string">&#x27;error&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="string">&quot;success&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> v = (<span class="built_in">parseFloat</span>(++imgNum) / images.length).toFixed(<span class="number">2</span>);</span><br><span class="line">      $(<span class="string">&quot;#percentShow&quot;</span>).html(<span class="built_in">Math</span>.round(v * <span class="number">100</span>) + <span class="string">&quot;&lt;sup&gt;%&lt;/sup&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  all: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">/*this will be called after all images loaded*/</span></span><br><span class="line">   $(<span class="string">&quot;#percentShow &quot;</span>).html(<span class="string">&quot;100&lt;sup&gt;%&lt;/sup&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">   $(<span class="string">&quot;percentShow&quot;</span>).fadeOut(<span class="number">1000</span>);</span><br><span class="line">   $(<span class="string">&quot;.main&quot;</span>).show();</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方式引用自其它博客,仅供借鉴</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getallBgimages</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url, B = [], A = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  A = B.slice.call(A, <span class="number">0</span>, A.length);</span><br><span class="line">  <span class="keyword">while</span> (A.length) &#123;</span><br><span class="line">    url = <span class="built_in">document</span>.deepCss(A.shift(), <span class="string">&#x27;background-image&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (url) url = <span class="regexp">/url\([&#x27;&#x27;]?([^&quot;)]+)/</span>.exec(url) || [];</span><br><span class="line">    url = url[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (url &amp;&amp; B.indexOf(url) == -<span class="number">1</span>) B[B.length] = url;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.deepCss = <span class="function"><span class="keyword">function</span> (<span class="params">who, css</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!who || !who.style) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> sty = css.replace(<span class="regexp">/\-([a-z])/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.toUpperCase();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (who.currentStyle) &#123;</span><br><span class="line">    <span class="keyword">return</span> who.style[sty] || who.currentStyle[sty] || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> dv = <span class="built_in">document</span>.defaultView || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">return</span> who.style[sty] ||</span><br><span class="line">  dv.getComputedStyle(who, <span class="string">&quot;&quot;</span>).getPropertyValue(css) || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.indexOf = <span class="built_in">Array</span>.prototype.indexOf ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">what, index</span>) </span>&#123;</span><br><span class="line">    index = index || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> L = <span class="built_in">this</span>.length;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; L) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>[index] === what) <span class="keyword">return</span> index;</span><br><span class="line">    ++index;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2016/08/28/mobile/160828/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2016/08/28/mobile/160828/" class="post-title-link" itemprop="url">Block循环引用之weak&strong</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2016-08-28 00:00:00" itemprop="dateCreated datePublished" datetime="2016-08-28T00:00:00+08:00">2016-08-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 16:01:08" itemprop="dateModified" datetime="2020-11-18T16:01:08+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">移动端</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>2.3k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>在 ARC 环境下，我们会使用 <code>_weak</code> 修饰符来修饰一个变量防止其在 <code>block</code> 中被循环引用，特殊情况下还会在 <code>block</code> 中使用 <code>_strong</code> 修饰符来修饰这个变量如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__weak __typeof(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="type">AFNetworkReachabilityStatusBlock</span> callback = ^(<span class="type">AFNetworkReachabilityStatus</span> status) &#123;</span><br><span class="line">  __strong __typeof(weakSelf)strongSelf = weakSelf;</span><br><span class="line">  strongSelf.networkReachabilityStatus = status;</span><br><span class="line">  <span class="keyword">if</span> (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class="line">    strongSelf.networkReachabilityStatusBlock(status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是因为在 <code>block</code> 中调用 <code>self</code> 会引起循环引用，同时在 <code>block</code> 中需要对 <code>weakSelf</code> 进行 <code>strong</code> 操作，保证 <code>self</code> 不会被释放，当<code>block</code>执行完会自动释放该 <code>strongSelf</code>。但实际上 <code>strong</code> 是为了防止野指针，而 <code>block</code> 里大部分是用 <code>weakSelf</code> 访问 <code>self</code> 的属性，而不是局部变量，我们也不可能主动释放 <code>self</code>，这样看来就没有 <code>strong</code> 的必要了当然不排除有特殊情况。</p><p>除开上面这种一般写法，我们看看 YYKit 中是怎么使用 <code>weak&amp;strong</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#ifndef weakify</span><br><span class="line">    #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">        #<span class="keyword">if</span> __has_feature(objc_arc)</span><br><span class="line">        #define weakify(object) autoreleasepool&#123;&#125; __weak __typeof__(object) <span class="keyword">weak</span>##<span class="number">_</span>##object = object;</span><br><span class="line">        #<span class="keyword">else</span></span><br><span class="line">        #define weakify(object) autoreleasepool&#123;&#125; __block __typeof__(object) block##<span class="number">_</span>##object = object;</span><br><span class="line">        #endif</span><br><span class="line">    #<span class="keyword">else</span></span><br><span class="line">        #<span class="keyword">if</span> __has_feature(objc_arc)</span><br><span class="line">        #define weakify(object) <span class="keyword">try</span>&#123;&#125; @finally&#123;&#125; &#123;&#125; __weak __typeof__(object) <span class="keyword">weak</span>##<span class="number">_</span>##object = object;</span><br><span class="line">        #<span class="keyword">else</span></span><br><span class="line">        #define weakify(object) <span class="keyword">try</span>&#123;&#125; @finally&#123;&#125; &#123;&#125; __block __typeof__(object) block##<span class="number">_</span>##object = object;</span><br><span class="line">        #endif</span><br><span class="line">    #endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef strongify</span><br><span class="line">    #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">        #<span class="keyword">if</span> __has_feature(objc_arc)</span><br><span class="line">        #define strongify(object) autoreleasepool&#123;&#125; __typeof__(object) object = <span class="keyword">weak</span>##<span class="number">_</span>##object;</span><br><span class="line">        #<span class="keyword">else</span></span><br><span class="line">        #define strongify(object) autoreleasepool&#123;&#125; __typeof__(object) object = block##<span class="number">_</span>##object;</span><br><span class="line">        #endif</span><br><span class="line">    #<span class="keyword">else</span></span><br><span class="line">        #<span class="keyword">if</span> __has_feature(objc_arc)</span><br><span class="line">        #define strongify(object) <span class="keyword">try</span>&#123;&#125; @finally&#123;&#125; __typeof__(object) object = <span class="keyword">weak</span>##<span class="number">_</span>##object;</span><br><span class="line">        #<span class="keyword">else</span></span><br><span class="line">        #define strongify(object) <span class="keyword">try</span>&#123;&#125; @finally&#123;&#125; __typeof__(object) object = block##<span class="number">_</span>##object;</span><br><span class="line">        #endif</span><br><span class="line">    #endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Example:</span></span><br><span class="line"><span class="comment">    @weakify(self)</span></span><br><span class="line"><span class="comment">    [self doSomething^&#123;</span></span><br><span class="line"><span class="comment">        @strongify(self)</span></span><br><span class="line"><span class="comment">        if (!self) return;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;];</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>还有来自 <a target="_blank" rel="noopener" href="https://github.com/jspahrsummers/libextobjc">libextobjc</a>的这种写法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define weakify(...) \\</span><br><span class="line">    autoreleasepool &#123;&#125; \\</span><br><span class="line">    metamacro_foreach_cxt(rac_weakify_,, __weak, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line">#define strongify(...) \\</span><br><span class="line">    <span class="keyword">try</span> &#123;&#125; @finally &#123;&#125; \\</span><br><span class="line">    _Pragma(<span class="string">&quot;clang diagnostic push&quot;</span>) \\</span><br><span class="line">    _Pragma(<span class="string">&quot;clang diagnostic ignored \\&quot;</span>-<span class="type">Wshadow</span>\\<span class="string">&quot;&quot;</span>) \\</span><br><span class="line">    metamacro_foreach(rac_strongify_,, __VA_ARGS__) \\</span><br><span class="line">    _Pragma(<span class="string">&quot;clang diagnostic pop&quot;</span>)</span><br></pre></td></tr></table></figure><p>其中细节可以参考这篇文章 <a target="_blank" rel="noopener" href="http://www.jianshu.com/p/3d6c4416db5e">http://www.jianshu.com/p/3d6c4416db5e</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2016/08/23/mobile/160823/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2016/08/23/mobile/160823/" class="post-title-link" itemprop="url">Swift3.0前瞻</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2016-08-23 00:00:00" itemprop="dateCreated datePublished" datetime="2016-08-23T00:00:00+08:00">2016-08-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 15:57:22" itemprop="dateModified" datetime="2020-11-18T15:57:22+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">移动端</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>3.7k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>3 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>在 WWDC16 上苹果公布了 Swift3.0，新的变化几乎会让你的代码处处报错，但正是借助于苹果这种追求极致的精神，Swift 才会发展的如此迅速，下面对 Swift3.0 带来的变化稍作总结。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ol><li>调用函数时首个参数必须指定参数名；</li></ol><p>在 Swift3.0 中不管是函数还是方法从第一个参数开始必须指定参数名（也可以使用 <code>_</code> 省略参数）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(num1: Int, num2: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line">sum(num1: <span class="number">1</span>, num2: <span class="number">2</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>函数参数取消可变类型；</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func increase(var a: Int) &#123;</span></span><br><span class="line"><span class="comment">//   a += 1</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 上面的写法会报错，可改为</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increase</span><span class="params">(a: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = a</span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>inout 参数修饰改放到参数类型前面；</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func increase(inout a: Int) &#123;</span></span><br><span class="line"><span class="comment">//   a += 1</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 上面的写法会报错，可改为</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increase</span><span class="params">( a:<span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>必须接受或者处理函数返回值；</li></ol><p>Swift3.0 中函数返回值必须要接收否则会警告，返回值没用时可以使用 <code>_</code> 接收来忽略，当然也可以增加 <code>@discardableResult</code> 声明，告诉编译器此方法不用接收返回值；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Caculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a: Int,b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@discardableResult</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">(a: Int,b: Int)</span></span> -&gt;<span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ca = <span class="type">Caculator</span>()</span><br><span class="line"><span class="comment">// 此处会警告</span></span><br><span class="line">ca.sum(a: <span class="number">1</span>, b: <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 使用&quot;_&quot;接收无用返回值</span></span><br><span class="line"><span class="keyword">let</span> <span class="number">_</span> = ca.sum(a: <span class="number">1</span>, b: <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 添加@discardableResult声明后不会警告</span></span><br><span class="line">ca.func1(a: <span class="number">1</span>, b: <span class="number">2</span>)</span><br></pre></td></tr></table></figure><ol start="5"><li>隐式可选类型和其他类型运算后获得可选类型而不是隐式可选类型；</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Int!</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 此时强制解包</span></span><br><span class="line"><span class="keyword">let</span> b = a + <span class="number">1</span></span><br><span class="line"><span class="comment">// 注意此时c是Int? 在之前版本中c是Int!</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a</span><br></pre></td></tr></table></figure><ol start="6"><li><code>selector</code> 格式改变为 <code>#selector(method(param1: param2:))</code>；</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a: Int,b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="number">_</span> = #selector(sum(a: b:))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>定义协议中可选方法必须使用 <code>@objc</code> 来修饰；</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// old: optional func func1()</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>取消 <code>++</code>、<code>--</code> 操作符；</li><li>取消 C 语言风格 <code>for</code> 循环；</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for var i = 0 ;i &lt; 10 ; i += 1 &#123;</span></span><br><span class="line"><span class="comment">//   debugPrint(i)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 上面写法会报错，改为如下</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>  ..&lt; <span class="number">10</span>  &#123;</span><br><span class="line">    <span class="built_in">debugPrint</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SDK-类库"><a href="#SDK-类库" class="headerlink" title="SDK 类库"></a>SDK 类库</h2><p>早起 Swift 为了保证 OC 开发人员顺利过渡到 Swift，很多类库和方法命名都尽量和 OC 保持一致，但是作为一门新语言 Swift 需要不断做出改变，这其中包括重新导入 Foundation 消除类型前缀、方法名去重、函数和方法去 C 风格等等。</p><h3 id="命名方式"><a href="#命名方式" class="headerlink" title="命名方式"></a>命名方式</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.去掉前缀</span></span><br><span class="line"><span class="keyword">let</span> url1 = <span class="type">URL</span>(string: <span class="string">&quot;www.cmjstudio.com&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> isFileURL = url1?.isFileURL <span class="comment">// old:url1.fileURL 现在更加注重语意</span></span><br><span class="line"><span class="keyword">let</span> data1 = <span class="type">Data</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.方法名使用动词, 其他词作为参数或移除</span></span><br><span class="line"><span class="keyword">var</span> array1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">array1.append(contentsOf: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]) <span class="comment">// old:array1.appendContentsOf([4,5,6])</span></span><br><span class="line">array1.remove(at: <span class="number">0</span>) <span class="comment">// old:array1.removeAtIndex(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.不引起歧义的情况下尽量消除重复</span></span><br><span class="line"><span class="keyword">let</span> color1 = <span class="type">UIColor</span>.red() <span class="comment">// old:var color1 = UIColor.redColor()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.枚举成员首字母变成小写</span></span><br><span class="line"><span class="keyword">let</span> label1 = <span class="type">UILabel</span>()</span><br><span class="line">label1.textAlignment = .center <span class="comment">// old:label1.textAlignment = .Center</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.去掉按钮Normal状态</span></span><br><span class="line"><span class="keyword">let</span> btn1 = <span class="type">UIButton</span>()</span><br><span class="line">btn1.setTitle(<span class="string">&quot;hello&quot;</span>, <span class="keyword">for</span>: <span class="type">UIControlState</span>()) <span class="comment">// 相当于Normal状态</span></span><br></pre></td></tr></table></figure><h3 id="去-C-风格"><a href="#去-C-风格" class="headerlink" title="去 C 风格"></a>去 C 风格</h3><p>Swift 初期很多类库的引入依然保持 OC 风格，但是由于 OC 根出自 C 语言，因此很多操作是 C 语言的函数形式，Swift3.0 之后全局函数将会变成某些类型的方法，某些常量定义将以某个枚举类型的成员来表示；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rect1 = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="comment">// 下面的代码会报错，3.0将废除这种类C风格</span></span><br><span class="line"><span class="comment">// old:let rect1 = CGRectMake(0, 0, 100, 100)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> context1 = <span class="type">UIGraphicsGetCurrentContext</span>() &#123;</span><br><span class="line">    <span class="type">CGContext</span>.fillPath(context1) <span class="comment">// old:CGContextFillPath(context1!)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCD改变</span></span><br><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">&quot;myqueue&quot;</span>)</span><br><span class="line">queue.async &#123;</span><br><span class="line">    <span class="built_in">debugPrint</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// old:</span></span><br><span class="line"><span class="comment">// let queue = dispatch_queue_create(&quot;myqueue&quot;, nil)</span></span><br><span class="line"><span class="comment">// dispatch_async(queue) &#123;</span></span><br><span class="line"><span class="comment">//    debugPrint(&quot;hello world!&quot;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相关常量定义被移到枚举内部</span></span><br><span class="line"><span class="type">NotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, selector: #selector(userDefaultChange()), name: <span class="type">UserDefaults</span>.didChangeNotification, object: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//old:NSNotificationCenter.defaultCenter().addObserver(self, selector: #selector(userDefaultChange()), name: NSUserDefaultsDidChangeNotification, object: nil)</span></span><br></pre></td></tr></table></figure><h3 id="API-变化"><a href="#API-变化" class="headerlink" title="API 变化"></a>API 变化</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> next = array1.index(after: <span class="number">0</span>)  <span class="comment">// old:let start = array1.startIndex let next = start.successor()</span></span><br><span class="line"><span class="comment">// 增加的新方法</span></span><br><span class="line"><span class="keyword">let</span> first = array1.first &#123; (element) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    element &gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = <span class="type">Range</span>(<span class="number">0</span>..&lt;<span class="number">3</span>) <span class="comment">//old: let _ = NSRange(location: 0, length: 3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码在控制器中执行，用于遍历当前view及其父视图</span></span><br><span class="line"><span class="keyword">for</span> subview <span class="keyword">in</span> sequence(first: <span class="keyword">self</span>.view, next: &#123; $<span class="number">0</span>?.superview &#125;) &#123;</span><br><span class="line">    <span class="built_in">debugPrint</span>(subview)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新浮点协议"><a href="#新浮点协议" class="headerlink" title="新浮点协议"></a>新浮点协议</h3><p>Float、Double、CGFloat 使用了新的协议，提供 <code>IEEE-754</code> 标准的属性和方法；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">2</span> * <span class="type">Float</span>.pi <span class="comment">// old: let a = 2 * M_PI</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2.0</span> * .pi <span class="comment">// 注意前面是浮点型，后面可以省略Float</span></span><br></pre></td></tr></table></figure><p>最后有必要提一下，之前有传闻说 Swift3.0 的语法和 API 都会稳定并且向上兼容，但是 WWDC 上官方证实这可能要到 Swift4 才能实现。但是过早的固定语法和 API 对于 Swift 的发展也不一定是好事，毕竟新特性的加入、更好的语法优化才能让 Swift 越来越好，更何况 Apple 提供了迁移工具也大大减少了迁移工作量。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2016/08/15/mobile/160815/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2016/08/15/mobile/160815/" class="post-title-link" itemprop="url">iOS交互Javascript</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2016-08-15 00:00:00" itemprop="dateCreated datePublished" datetime="2016-08-15T00:00:00+08:00">2016-08-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 15:57:22" itemprop="dateModified" datetime="2020-11-18T15:57:22+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">移动端</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>5.1k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>为了解决 UIWebView 加载速度慢、占用内存大的问题，苹果在 iOS8.0 之后推出了 WKWebView 以替代之，在使用 WKWebView 前先引入 <code>&lt;WebKit/WebKit.h&gt;</code> 框架。</p><h2 id="WKWebView-属性"><a href="#WKWebView-属性" class="headerlink" title="WKWebView 属性"></a>WKWebView 属性</h2><p>WKWebView 在原有基础上额外添加了几个属性如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器配置;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">WKWebViewConfiguration</span> *configuration;</span><br><span class="line"><span class="comment">// 历史访问列表;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">WKBackForwardList</span> *backForwardList;</span><br><span class="line"><span class="comment">// 网页加载进度;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">double</span> estimatedProgress;</span><br></pre></td></tr></table></figure><h2 id="WKWebView-代理"><a href="#WKWebView-代理" class="headerlink" title="WKWebView 代理"></a>WKWebView 代理</h2><p>WKWebView 可以同时设置 WKNavigationDelegate 和 WKUIDelegate 两个代理，代理方法也有所改变如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - WKNavigationDelegate</span></span><br><span class="line"><span class="comment">// 在发送请求前的操作;</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler &#123;&#125;</span><br><span class="line"><span class="comment">// 在收到响应后的操作;</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationResponse:(<span class="built_in">WKNavigationResponse</span> *)navigationResponse decisionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">WKNavigationResponsePolicy</span>))decisionHandler &#123;&#125;</span><br><span class="line"><span class="comment">// 在页面重指向时的操作;</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didReceiveServerRedirectForProvisionalNavigation:(<span class="built_in">WKNavigation</span> *)navigation &#123;&#125;</span><br><span class="line"><span class="comment">// 页面准备加载;</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didStartProvisionalNavigation:(<span class="built_in">WKNavigation</span> *)navigation &#123;&#125;</span><br><span class="line"><span class="comment">// 页面开始加载;</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didCommitNavigation:(<span class="built_in">WKNavigation</span> *)navigation &#123;&#125;</span><br><span class="line"><span class="comment">// 页面完成加载;</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didFinishNavigation:(<span class="built_in">WKNavigation</span> *)navigation &#123;&#125;</span><br><span class="line"><span class="comment">// 页面加载失败;</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didFailProvisionalNavigation:(<span class="built_in">WKNavigation</span> *)navigation withError:(<span class="built_in">NSError</span> *)error &#123;&#125;</span><br><span class="line"><span class="comment">// 页面跳转失败;</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didFailNavigation:(<span class="built_in">WKNavigation</span> *)navigation withError:(<span class="built_in">NSError</span> *)error &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - WKUIDelegate</span></span><br><span class="line"><span class="comment">// 创建新的WebView;</span></span><br><span class="line">- (<span class="built_in">WKWebView</span> *)webView:(<span class="built_in">WKWebView</span> *)webView createWebViewWithConfiguration:(<span class="built_in">WKWebViewConfiguration</span> *)configuration forNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction windowFeatures:(<span class="built_in">WKWindowFeatures</span> *)windowFeatures &#123;&#125;</span><br><span class="line"><span class="comment">// 拦截警告框</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView runJavaScriptAlertPanelWithMessage:(<span class="built_in">NSString</span> *)message initiatedByFrame:(<span class="built_in">WKFrameInfo</span> *)frame completionHandler:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completionHandler &#123;&#125;</span><br><span class="line"><span class="comment">// 拦截确认框</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView runJavaScriptConfirmPanelWithMessage:(<span class="built_in">NSString</span> *)message initiatedByFrame:(<span class="built_in">WKFrameInfo</span> *)frame completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span>))completionHandler &#123;&#125;</span><br><span class="line"><span class="comment">// 拦截提示框</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView runJavaScriptTextInputPanelWithPrompt:(<span class="built_in">NSString</span> *)prompt defaultText:(<span class="built_in">NSString</span> *)defaultText initiatedByFrame:(<span class="built_in">WKFrameInfo</span> *)frame completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSString</span> * _Nullable))completionHandler &#123;&#125;</span><br></pre></td></tr></table></figure><p>此外 WKWebView 新增了根据文件加载 WebView 的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)loadFileURL:(<span class="built_in">NSURL</span> *)URL allowingReadAccessToURL:(<span class="built_in">NSURL</span> *)readAccessURL <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">9</span>_0);</span><br></pre></td></tr></table></figure><h2 id="WebViewJavascriptBridge-实现交互"><a href="#WebViewJavascriptBridge-实现交互" class="headerlink" title="WebViewJavascriptBridge 实现交互"></a>WebViewJavascriptBridge 实现交互</h2><p>在项目中使用 WebViewJavascriptBridge 先添加 OC 代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WKWebView</span>* webView = [[<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;WKWebView&quot;</span>) alloc] initWithFrame:<span class="keyword">self</span>.view.bounds];</span><br><span class="line">webView.navigationDelegate = <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:webView];</span><br><span class="line"><span class="comment">// 设置允许桥接</span></span><br><span class="line">[<span class="built_in">WKWebViewJavascriptBridge</span> enableLogging];</span><br><span class="line"><span class="comment">// 初始化桥接对象并设置代理</span></span><br><span class="line">_bridge = [<span class="built_in">WKWebViewJavascriptBridge</span> bridgeForWebView:webView];</span><br><span class="line">[_bridge setWebViewDelegate:<span class="keyword">self</span>];</span><br><span class="line"><span class="comment">// 注册函数testObjcCallback引用JS</span></span><br><span class="line">[_bridge registerHandler:<span class="string">@&quot;testObjcCallback&quot;</span> handler:^(<span class="keyword">id</span> data, WVJBResponseCallback responseCallback) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;testObjcCallback called: %@&quot;</span>, data);</span><br><span class="line">    responseCallback(<span class="string">@&quot;Response from testObjcCallback&quot;</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 回调函数testJavascriptHandler供JS引用</span></span><br><span class="line">[_bridge callHandler:<span class="string">@&quot;testJavascriptHandler&quot;</span> data:@&#123; <span class="string">@&quot;foo&quot;</span>:<span class="string">@&quot;before ready&quot;</span> &#125;];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> renderButtons:webView];</span><br><span class="line">[<span class="keyword">self</span> loadExamplePage:webView];</span><br></pre></td></tr></table></figure><p>然后在 HTML 文件中添加 <code>js</code> 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupWebViewJavascriptBridge</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.WebViewJavascriptBridge) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(WebViewJavascriptBridge)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.WVJBCallbacks) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.WVJBCallbacks.push(callback)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.WVJBCallbacks = [callback]</span><br><span class="line">  <span class="keyword">var</span> WVJBIframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>)</span><br><span class="line">  WVJBIframe.style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">  WVJBIframe.src = <span class="string">&#x27;wvjbscheme://__BRIDGE_LOADED__&#x27;</span></span><br><span class="line">  <span class="built_in">document</span>.documentElement.appendChild(WVJBIframe)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.documentElement.removeChild(WVJBIframe)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OC-引用-JS"><a href="#OC-引用-JS" class="headerlink" title="OC 引用 JS"></a>OC 引用 JS</h3><p>OC 中注册函数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[_bridge registerHandler:<span class="string">@&quot;testObjcCallback&quot;</span> handler:^(<span class="keyword">id</span> data, WVJBResponseCallback responseCallback) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;testObjcCallback called: %@&quot;</span>, data);</span><br><span class="line">    responseCallback(<span class="string">@&quot;Response from testObjcCallback&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>JS 中实现回调函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setupWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span>(<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">  bridge.callHandler(<span class="string">&#x27;testObjcCallback&#x27;</span>, &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 该函数为js中声明的函数;</span></span><br><span class="line">    log(<span class="string">&#x27;JS got response&#x27;</span>, response)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="JS-引用-OC"><a href="#JS-引用-OC" class="headerlink" title="JS 引用 OC"></a>JS 引用 OC</h3><p>JS 中注册函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bridge.registerHandler(<span class="string">&#x27;testJavascriptHandler&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data, responseCallback</span>) </span>&#123;</span><br><span class="line">  log(<span class="string">&#x27;ObjC called testJavascriptHandler with&#x27;</span>, data)</span><br><span class="line">  <span class="keyword">var</span> responseData = &#123; <span class="string">&#x27;Javascript Says&#x27;</span>: <span class="string">&#x27;Right back atcha!&#x27;</span> &#125;</span><br><span class="line">  log(<span class="string">&#x27;JS responding with&#x27;</span>, responseData)</span><br><span class="line">  responseCallback(responseData)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>OC 中实现回调并传值：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_bridge callHandler:<span class="string">@&quot;testJavascriptHandler&quot;</span> data:@&#123; <span class="string">@&quot;foo&quot;</span>:<span class="string">@&quot;before ready&quot;</span> &#125;];</span><br></pre></td></tr></table></figure><p>以上就是 WebViewJavascriptBridge 与 WKWebView 的基本交互使用。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2016/08/02/mobile/160802/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2016/08/02/mobile/160802/" class="post-title-link" itemprop="url">OC与Swift混编</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2016-08-02 00:00:00" itemprop="dateCreated datePublished" datetime="2016-08-02T00:00:00+08:00">2016-08-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 15:57:22" itemprop="dateModified" datetime="2020-11-18T15:57:22+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">移动端</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>504</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="OC-引用-Swift"><a href="#OC-引用-Swift" class="headerlink" title="OC 引用 Swift"></a>OC 引用 Swift</h2><p>在混合项目中 Swift 代码默认使用 <code>module</code> 管理，这时想要 OC 引用 Swift 需要把 Swift 代码作为 <code>module</code> 暴露给整个项目，修改 Build Settings 如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/1480065-da206521f0347aff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="1"></p><p>然后创建一个 <code>ProjectName.swift</code> 文件,在 OC 文件中引入该文件就可以随意引用 Swift 代码了;</p><h2 id="Swift-引用-OC"><a href="#Swift-引用-OC" class="headerlink" title="Swift 引用 OC"></a>Swift 引用 OC</h2><p>同理，Swift 引用 OC 是通过 ProjectName-Bridging-Header 将 OC 代码暴露给整个项目，这里需要考虑两种情况如下：</p><ol><li><p>在 Swift 项目中创建 OC 文件会自动生成 ProjectName-Bridging-Header 文件，在该桥接文件里引入 OC 头文件就可以引用 OC 代码了，同时系统帮我们设置好了文件路径；</p></li><li><p>如果最初创建 OC 文件时没有创建桥接文件，此后创建 OC 文件不会提示创建桥接文件，这时需要自己创建桥接文件 ProjectName-Bridging-Header 如下</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1480065-e835e7ad22de0583.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/730/format/webp" alt="2"></p><p>手动创建桥接文件后要在 Build Settings 中设置路径，搜索 <code>bridging</code> 找到 <code>Swift Compiler-General -&gt; Objective-C Bridging Header</code>，然后把桥接文件拖进来就大功告成了。</p><p><img src="https://upload-images.jianshu.io/upload_images/1480065-d0757040ef39c92f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/790/format/webp" alt="3"></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.nirongfei.site/blog-hexo/2016/07/24/mobile/160724/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog-hexo/images/avatar.png"><meta itemprop="name" content="阳明先生"><meta itemprop="description" content="知之真切笃实处即是行 行之明觉精察处即是知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="阳明先生"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/blog-hexo/2016/07/24/mobile/160724/" class="post-title-link" itemprop="url">iOS开发问题汇总</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2016-07-24 00:00:00" itemprop="dateCreated datePublished" datetime="2016-07-24T00:00:00+08:00">2016-07-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-18 16:01:08" itemprop="dateModified" datetime="2020-11-18T16:01:08+08:00">2020-11-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog-hexo/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">移动端</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1.2k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h4 id="pch-was-compiled-with-module-cache…"><a href="#pch-was-compiled-with-module-cache…" class="headerlink" title="pch was compiled with module cache…"></a>pch was compiled with module cache…</h4><p>解决方法：<br>1.Close your project or workspace.<br>2.In Finder: ⇧shift+⌘cmd+G<br>3.Paste: ~/Library/Developer/Xcode/DerivedData/<br>4.Delete the ModuleCache folder and empty trash.<br>5.Open up your project.<br>6.Clean: ⇧shift+⌘cmd+K<br>7.Build: ⌘cmd+B</p><hr><h4 id="The-file-“Logs”-couldn’t-be-saved-in-the-folder-“Library”-because-a-file-with-the-same-name-already-exists"><a href="#The-file-“Logs”-couldn’t-be-saved-in-the-folder-“Library”-because-a-file-with-the-same-name-already-exists" class="headerlink" title="The file “Logs” couldn’t be saved in the folder “Library” because a file with the same name already exists."></a>The file “Logs” couldn’t be saved in the folder “Library” because a file with the same name already exists.</h4><p>解决方法：<br>iOS Simulator -&gt; Reset Content and Settings.</p><hr><h4 id="Your-build-settings-specify-a-provisioning-profile-with-the-UUID-no-provisioning-profile-was-found"><a href="#Your-build-settings-specify-a-provisioning-profile-with-the-UUID-no-provisioning-profile-was-found" class="headerlink" title="Your build settings specify a provisioning profile with the UUID,no provisioning profile was found"></a>Your build settings specify a provisioning profile with the UUID,no provisioning profile was found</h4><p>解决方法： 1.找到项目 xcodeproj 文件,右键打开包内容; 2.找到 project.pbxproj 文件全局搜索“PROVISIONING_PROFILE”,将相关 UUID 都删除; 3.保存文件重新打开项目,重新安装 provisioning profile 文件即可.</p><hr><h4 id="Error-returned-in-reply-Connection-invalid"><a href="#Error-returned-in-reply-Connection-invalid" class="headerlink" title="Error returned in reply:Connection invalid."></a>Error returned in reply:Connection invalid.</h4><p>解决方法：<br>重启 Xcode 和模拟器即可.</p><hr><h4 id="Swift-中-pods-导入-OC-库报-file-not-found"><a href="#Swift-中-pods-导入-OC-库报-file-not-found" class="headerlink" title="Swift 中 pods 导入 OC 库报 file not found"></a>Swift 中 pods 导入 OC 库报 file not found</h4><p>解决方法:<br>1.target-&gt;Build Settings-&gt;Objective-C Bridging Header,设置路径; 2.在 Bridging-Header(桥接文件)中  引入.h 文件要包含上层文件夹,否则 Xcode 找不到: <code>#import &quot;AFNetworking/AFNetworking.h&quot;</code></p><hr><h4 id="Cornerstone-无法上传项目-a-文件"><a href="#Cornerstone-无法上传项目-a-文件" class="headerlink" title="Cornerstone 无法上传项目.a 文件"></a>Cornerstone 无法上传项目.a 文件</h4><p>解决方法:<br>1.cmd+,进入设置界面,选中 Subversion 取消选项 Use default global ignores;<br>2. 终端输入<code>vi ~/.subversion/config</code>找到<code># global-ignores = *.o *.lo *.la *.al .libs *.so *.so.[0-9]* *.a *.pyc *.pyo # *.rej *~ #*# .#* .*.swp .DS_Store</code>,输入<code>i</code>进入编辑模式  替换成<code>global-ignores = *.o *.lo *.la *.al .libs *.so *.so.[0-9]* *.pyc *.pyo *.rej *~ #*# .#* .*.swp .DS_Store</code>,输入<code>:wq</code>保存退出;</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><nav class="pagination"><a class="extend prev" rel="prev" href="/blog-hexo/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog-hexo/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog-hexo/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/blog-hexo/page/7/">7</a><a class="extend next" rel="next" href="/blog-hexo/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="阳明先生" src="/blog-hexo/images/avatar.png"><p class="site-author-name" itemprop="name">阳明先生</p><div class="site-description" itemprop="description">知之真切笃实处即是行 行之明觉精察处即是知</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/blog-hexo/archives/"><span class="site-state-item-count">63</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/blog-hexo/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/blog-hexo/tags/"><span class="site-state-item-count">25</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/NiRongFei" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;NiRongFei" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">阳明先生</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">442k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">6:42</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/blog-hexo/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/blog-hexo/lib/velocity/velocity.min.js"></script><script src="/blog-hexo/lib/velocity/velocity.ui.min.js"></script><script src="/blog-hexo/js/utils.js"></script><script src="/blog-hexo/js/motion.js"></script><script src="/blog-hexo/js/schemes/pisces.js"></script><script src="/blog-hexo/js/next-boot.js"></script><script async src="/js/typing.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,document.body.addEventListener("input",POWERMODE)</script></body></html>